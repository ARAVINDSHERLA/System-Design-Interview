* Nagios CheatSheet                                               :Tools:
:PROPERTIES:
:type:     monitoring, tool
:export_file_name: cheatsheet-nagios-A4.pdf
:END:

#+BEGIN_HTML
<a href="https://github.com/dennyzhang/cheatsheet.dennyzhang.com/tree/master/cheatsheet-nagios-A4"><img align="right" width="200" height="183" src="https://www.dennyzhang.com/wp-content/uploads/denny/watermark/github.png" /></a>
<div id="the whole thing" style="overflow: hidden;">
<div style="float: left; padding: 5px"> <a href="https://www.linkedin.com/in/dennyzhang001"><img src="https://www.dennyzhang.com/wp-content/uploads/sns/linkedin.png" alt="linkedin" /></a></div>
<div style="float: left; padding: 5px"><a href="https://github.com/dennyzhang"><img src="https://www.dennyzhang.com/wp-content/uploads/sns/github.png" alt="github" /></a></div>
<div style="float: left; padding: 5px"><a href="https://www.dennyzhang.com/slack" target="_blank" rel="nofollow"><img src="https://www.dennyzhang.com/wp-content/uploads/sns/slack.png" alt="slack"/></a></div>
</div>

<br/><br/>
<a href="http://makeapullrequest.com" target="_blank" rel="nofollow"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg" alt="PRs Welcome"/></a>
#+END_HTML

- PDF Link: [[https://github.com/dennyzhang/cheatsheet.dennyzhang.com/blob/master/cheatsheet-nagios-A4/cheatsheet-nagios-A4.pdf][cheatsheet-nagios-A4.pdf]], Category: [[https://cheatsheet.dennyzhang.com/category/tools/][tools]]
- Blog URL: https://cheatsheet.dennyzhang.com/cheatsheet-nagios-A4
- Related posts: [[https://cheatsheet.dennyzhang.com/cheatsheet-prometheus-A4][Prometheus CheatSheet]], [[https://github.com/topics/denny-cheatsheets][#denny-cheatsheets]]

File me [[https://github.com/dennyzhang/cheatsheet.dennyzhang.com/issues][Issues]] or star [[https://github.com/dennyzhang/cheatsheet.dennyzhang.com][this repo]].
** Nagios Summary
| Name                            | Summary                                                                        |
|---------------------------------+--------------------------------------------------------------------------------|
| nagiosadmin                     | =/etc/nagios3/htpasswd.users=                                                  |
| server url                      | http://$nagios_ip/nagios3/                                                     |
| NRPE: customized checks         | =/etc/nagios/nrpe.cfg=                                                         |
| npre                            | =/var/run/nagios/nrpe.pid= nagios-nrpe-server port:5666                        |
| nagios                          | =tree /var/lib/nagios3/=                                                       |
| Nagios conf                     | =/etc/nagios3/conf.d=, =/etc/nagios3/nagios.cfg=                               |
| historical                      | =/var/log/nagios3/nagios.log=                                                  |
| nagios retention file           | =/var/lib/nagios3/retention.dat=                                               |
| nagios status file              | =/var/cache/nagios3/status.dat=                                                |
| nagios plugins                  | =/usr/lib/nagios/plugins=                                                      |
| nagios rrd                      | =/usr/local/nagiosgraph/var/rrd/localhost=                                     |
| nagiosgraph conf                | =/usr/local/nagiosgraph/etc=, =/usr/local/nagiosgraph/etc/nagiosgraph.conf=    |
| nagiosgraph log                 | =/usr/local/nagiosgraph/var/nagiosgraph.log=                                   |
| dataset options for nagiosgraph | =/usr/local/nagiosgraph/etc/datasetdb.conf=                                    |
| check_nrpe command              | =/etc/nagios-plugins/config/check_nrpe.cfg=                                    |
** Nagios Check status
| Name          | Summary                                                               |
|---------------+-----------------------------------------------------------------------|
| Ubuntu/Debian | =/etc/init.d/nagios3 status=, =/etc/init.d/nagios-nrpe-server status= |
| CentOS/Fedora | =/etc/init.d/nagios status=, =/etc/init.d/nrpe status=                |
** Nagios Check & Plugins
| Name           | Summary                                                                        |
|----------------+--------------------------------------------------------------------------------|
| memory check   | =/usr/lib/nagios/plugins/check_nrpe -H 127.0.0.1 -c check_MEMORY=              |
| disk check     | =/usr/lib/nagios/plugins/check_linux_stats.pl -M -w 95,90 -c 100,95=           |
| disk check     | =/usr/lib/nagios/plugins/check_nrpe -H 172.20.18.17 -c check_DISK_USAGE -t 20= |
| http check     | =/usr/lib/nagios/plugins/check_http -H www.dennyzhang.com -p 80=               |
| ssh check      | =/usr/lib/nagios/plugins/check_by_ssh -H 127.0.0.1 -C date -l mac=             |
| check_proc_cpu | [[https://www.dennyzhang.com/nagois_monitor_process_cpu][Nagios Plugin: Monitor Service CPU]]                                             |
| check_proc_fd  | [[https://www.dennyzhang.com/nagois_monitor_process_fd][Nagios Plugin: Monitor Process FD]]                                              |
| check_proc_mem | [[https://www.dennyzhang.com/nagois_monitor_process_memory][Nagios Plugin: Monitor Service Memory]]                                          |
** More Resources
License: Code is licensed under [[https://www.dennyzhang.com/wp-content/mit_license.txt][MIT License]].
#+BEGIN_HTML
<a href="https://cheatsheet.dennyzhang.com"><img align="right" width="201" height="268" src="https://raw.githubusercontent.com/USDevOps/mywechat-slack-group/master/images/denny_201706.png"></a>
<a href="https://cheatsheet.dennyzhang.com"><img align="right" src="https://raw.githubusercontent.com/dennyzhang/cheatsheet.dennyzhang.com/master/images/cheatsheet_dns.png"></a>

<a href="https://www.linkedin.com/in/dennyzhang001"><img align="bottom" src="https://www.dennyzhang.com/wp-content/uploads/sns/linkedin.png" alt="linkedin" /></a>
<a href="https://github.com/dennyzhang"><img align="bottom"src="https://www.dennyzhang.com/wp-content/uploads/sns/github.png" alt="github" /></a>
<a href="https://www.dennyzhang.com/slack" target="_blank" rel="nofollow"><img align="bottom" src="https://www.dennyzhang.com/wp-content/uploads/sns/slack.png" alt="slack"/></a>
#+END_HTML
* org-mode configuration                                           :noexport:
#+STARTUP: overview customtime noalign logdone showall
#+DESCRIPTION:
#+KEYWORDS:
#+LATEX_HEADER: \usepackage[margin=0.6in]{geometry}
#+LaTeX_CLASS_OPTIONS: [8pt]
#+LATEX_HEADER: \usepackage[english]{babel}
#+LATEX_HEADER: \usepackage{lastpage}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \pagestyle{fancy}
#+LATEX_HEADER: \fancyhf{}
#+LATEX_HEADER: \rhead{Updated: \today}
#+LATEX_HEADER: \rfoot{\thepage\ of \pageref{LastPage}}
#+LATEX_HEADER: \lfoot{\href{https://github.com/dennyzhang/cheatsheet.dennyzhang.com/tree/master/cheatsheet-nagios-A4}{GitHub: https://github.com/dennyzhang/cheatsheet.dennyzhang.com/tree/master/cheatsheet-nagios-A4}}
#+LATEX_HEADER: \lhead{\href{https://cheatsheet.dennyzhang.com/cheatsheet-nagios-A4}{Blog URL: https://cheatsheet.dennyzhang.com/cheatsheet-nagios-A4}}
#+AUTHOR: Denny Zhang
#+EMAIL:  denny@dennyzhang.com
#+TAGS: noexport(n)
#+PRIORITIES: A D C
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+EXPORT_EXCLUDE_TAGS: exclude noexport
#+SEQ_TODO: TODO HALF ASSIGN | DONE BYPASS DELEGATE CANCELED DEFERRED
#+LINK_UP:
#+LINK_HOME:
* [#A] Nagios Monitoring system                                    :noexport:
** DONE [#B] Nagios checks
  CLOSED: [2014-07-21 Mon 10:12]
command[check_users]=/usr/lib/nagios/plugins/check_users -w 5 -c 10
command[check_load]=/usr/lib/nagios/plugins/check_load -w 15,10,5 -c 30,25,20
command[check_hda1]=/usr/lib/nagios/plugins/check_disk -w 20% -c 10% -p /dev/hda1
command[check_zombie_procs]=/usr/lib/nagios/plugins/check_procs -w 5 -c 10 -s Z
command[check_total_procs]=/usr/lib/nagios/plugins/check_procs -w 150 -c 200
*** grep allowed_hosts /etc/nagios/nrpe.cfg
*** nrep.cfg
#+begin_example
root@ubuntu:~# grep command /etc/nagios/nrpe.cfg
# to specify arguments to commands that are executed.  This option only works
# if the daemon was configured with the --enable-command-args configure script
# Values: 0=do not allow arguments, 1=allow command arguments
# This option allows you to prefix all commands with a user-defined string.
# command line from the command definition.
# This lets the nagios user run all commands in that directory (and only them)
# command_prefix=/usr/bin/sudo
command_timeout=60
# command[<command_name>]=<command_line>
# When the daemon receives a request to return the results of <command_name>
# it will execute the command specified by the <command_line> argument.
# Unlike Nagios, the command line cannot contain macros - it must be
# Note: Any plugins that are used in the command lines must reside
# The following examples use hardcoded command arguments...
command[check_users]=/usr/lib/nagios/plugins/check_users -w 5 -c 10
command[check_load]=/usr/lib/nagios/plugins/check_load -w 15,10,5 -c 30,25,20
command[check_hda1]=/usr/lib/nagios/plugins/check_disk -w 20% -c 10% -p /dev/hda1
command[check_zombie_procs]=/usr/lib/nagios/plugins/check_procs -w 5 -c 10 -s Z
command[check_total_procs]=/usr/lib/nagios/plugins/check_procs -w 150 -c 200
# command arguments *AND* the dont_blame_nrpe directive in this
#command[check_users]=/usr/lib/nagios/plugins/check_users -w $ARG1$ -c $ARG2$
#command[check_load]=/usr/lib/nagios/plugins/check_load -w $ARG1$ -c $ARG2$
#command[check_disk]=/usr/lib/nagios/plugins/check_disk -w $ARG1$ -c $ARG2$ -p $ARG3$
#command[check_procs]=/usr/lib/nagios/plugins/check_procs -w $ARG1$ -c $ARG2$ -s $ARG3$
#+end_example
*** tree /usr/lib/nagios/plugins
#+begin_example
root@ubuntu:~# tree /usr/lib/nagios/plugins
/usr/lib/nagios/plugins
├── check_apt
├── check_bgpstate
├── check_breeze
├── check_by_ssh
├── check_clamd -> check_tcp
├── check_cluster
├── check_dhcp
├── check_dig
├── check_disk
├── check_disk_smb
├── check_dns
├── check_dummy
├── check_file_age
├── check_flexlm
├── check_ftp -> check_tcp
├── check_host -> check_icmp
├── check_hpjd
├── check_http
├── check_icmp
├── check_ide_smart
├── check_ifoperstatus
├── check_ifstatus
├── check_imap -> check_tcp
├── check_ircd
├── check_jabber -> check_tcp
├── check_ldap
├── check_ldaps -> check_ldap
├── check_linux_raid
├── check_load
├── check_log
├── check_mailq
├── check_mrtg
├── check_mrtgtraf
├── check_mysql
├── check_mysql_query
├── check_nagios
├── check_nntp -> check_tcp
├── check_nntps -> check_tcp
├── check_nrpe
├── check_nt
├── check_ntp
├── check_ntp_peer
├── check_ntp_time
├── check_nwstat
├── check_oracle
├── check_overcr
├── check_pgsql
├── check_ping
├── check_pop -> check_tcp
├── check_procs
├── check_radius
├── check_real
├── check_rpc
├── check_rta_multi -> check_icmp
├── check_sensors
├── check_simap -> check_tcp
├── check_smtp
├── check_snmp
├── check_spop -> check_tcp
├── check_ssh
├── check_ssmtp -> check_tcp
├── check_swap
├── check_tcp
├── check_time
├── check_udp -> check_tcp
├── check_ups
├── check_users
├── check_wave
├── negate
├── urlize
├── utils.pm
└── utils.sh

#+end_example
** DONE Ubuntu setup nagios
  CLOSED: [2014-07-21 Mon 10:12]
https://www.digitalocean.com/community/tutorials/how-to-install-nagios-on-ubuntu-12-10

sudo su -
sudo apt-get install -y nagios3 nagios-nrpe-plugin

usermod -a -G nagios www-data
chmod -R g+x /var/lib/nagios3/
cp /etc/nagios3/nagios.cfg /etc/nagios3/nagios.cfg.bak
sed -i 's/check_external_commands=0/check_external_commands=1/g' /etc/nagios3/nagios.cfg

#Set Password Protection:
htpasswd -c /etc/nagios3/htpasswd.users nagiosadmin
service nagios3 restart && service apache2 restart

#Install NRPE on Client:
apt-get install -y nagios-plugins nagios-nrpe-server

service nagios-nrpe-server start
** DONE [#A] nagio rrd: /usr/local/nagiosgraph
  CLOSED: [2014-07-22 Tue 18:20]
http://www.linuxfunda.com/2013/04/02/steps-to-configure-nagiosgraph-with-nagios-core/

ls -lth /usr/local/nagiosgraph/var/rrd

http://172.16.33.200/nagiosgraph/cgi-bin/showconfig.cgi

/usr/local/nagiosgraph/var/rrd/qa1b.thecloudpass.com
http://sachinharma.blogspot.com/2013/08/nagiosgraph-graphs-in-nagios-on_7.html

sudo apt-get install librrds-perl libgd-gd2-perl
cd /home/denny
wget http://downloads.sourceforge.net/project/nagiosgraph/nagiosgraph/1.4.4/nagiosgraph-1.4.4.tar.gz
tar -xzf nagiosgraph-1.4.4.tar.gz
cd nagiosgraph-1.4.4
./install.pl --check-prereq
./install.pl --install

vim /etc/nagios3/nagios.cfg
#+begin_example
   # begin nagiosgraph configuration
   # process nagios performance data using nagiosgraph
   process_performance_data=1
   service_perfdata_file=/tmp/perfdata.log
   service_perfdata_file_template=$LASTSERVICECHECK$||$HOSTNAME$||$SERVICEDESC$||$SERVICEOUTPUT$||$SERVICEPERFDATA$
   service_perfdata_file_mode=a
   service_perfdata_file_processing_interval=30
   service_perfdata_file_processing_command=process-service-perfdata-for-nagiosgraph
   # end nagiosgraph configuration
#+end_example

vim commands.cfg
define command {
command_name process-service-perfdata-for-nagiosgraph
command_line /usr/local/nagiosgraph/bin/insert.pl
}

vim /etc/apache2/httpd.conf
Include /usr/local/nagiosgraph/etc/nagiosgraph-apache.conf
*** ./install.pl --install
#+begin_example
root@ubuntu:/tmp/nagiosgraph-1.4.4# ./install.pl --install
checking required PERL modules
  Carp...1.20
  CGI...3.52
  Data::Dumper...2.130_02
  File::Basename...2.82
  File::Find...1.19
  MIME::Base64...3.13
  POSIX...1.24
  RRDs...1.4007
  Time::HiRes...1.972101
checking optional PERL modules
  GD...2.46
checking nagios installation
  found nagios at /usr/sbin/nagios3
checking web server installation
  found apache at /usr/sbin/apache2
Destination directory (prefix)? [/usr/local/nagiosgraph]
Location of configuration files (etc-dir)? [/usr/local/nagiosgraph/etc]
Location of executables? [/usr/local/nagiosgraph/bin]
Location of CGI scripts? [/usr/local/nagiosgraph/cgi]
Location of documentation (doc-dir)? [/usr/local/nagiosgraph/doc]
Location of examples? [/usr/local/nagiosgraph/examples]
Location of CSS and JavaScript files? [/usr/local/nagiosgraph/share]
Location of utilities? [/usr/local/nagiosgraph/util]
Location of state files (var-dir)? [/usr/local/nagiosgraph/var]
Location of RRD files? [/usr/local/nagiosgraph/var/rrd]
Location of log files (log-dir)? [/usr/local/nagiosgraph/var]
Path of log file? [/usr/local/nagiosgraph/var/nagiosgraph.log]
Path of CGI log file? [/usr/local/nagiosgraph/var/nagiosgraph-cgi.log]
URL of CGI scripts? [/nagiosgraph/cgi-bin]
URL of CSS file? [/nagiosgraph/nagiosgraph.css]
URL of JavaScript file? [/nagiosgraph/nagiosgraph.js]
Path of Nagios performance data file? [/tmp/perfdata.log]
URL of Nagios CGI scripts? [/nagios/cgi-bin]
username or userid of Nagios user? [nagios]
username or userid of web server user? [www-data]
Modify the Nagios configuration? [n]
Modify the Apache configuration? [n]
configuration:
  ng_layout            standalone
  ng_prefix            /usr/local/nagiosgraph
  ng_etc_dir           /usr/local/nagiosgraph/etc
  ng_bin_dir           /usr/local/nagiosgraph/bin
  ng_cgi_dir           /usr/local/nagiosgraph/cgi
  ng_doc_dir           /usr/local/nagiosgraph/doc
  ng_examples_dir      /usr/local/nagiosgraph/examples
  ng_www_dir           /usr/local/nagiosgraph/share
  ng_util_dir          /usr/local/nagiosgraph/util
  ng_var_dir           /usr/local/nagiosgraph/var
  ng_rrd_dir           /usr/local/nagiosgraph/var/rrd
  ng_log_dir           /usr/local/nagiosgraph/var
  ng_log_file          /usr/local/nagiosgraph/var/nagiosgraph.log
  ng_cgilog_file       /usr/local/nagiosgraph/var/nagiosgraph-cgi.log
  ng_url               /nagiosgraph
  ng_cgi_url           /nagiosgraph/cgi-bin
  ng_css_url           /nagiosgraph/nagiosgraph.css
  ng_js_url            /nagiosgraph/nagiosgraph.js
  nagios_cgi_url       /nagios/cgi-bin
  nagios_perfdata_file /tmp/perfdata.log
  nagios_user          nagios
  www_user             www-data
  modify_nagios_config n
  nagios_config_file
  nagios_commands_file
  modify_apache_config n
  apache_config_dir
  apache_config_file
Continue with this configuration? [y] y
mkdir /usr/local/nagiosgraph
mkdir /usr/local/nagiosgraph/etc
copy etc/nagiosgraph_de.conf to /usr/local/nagiosgraph/etc/nagiosgraph_de.conf
copy etc/groupdb.conf to /usr/local/nagiosgraph/etc/groupdb.conf
copy etc/servdb.conf to /usr/local/nagiosgraph/etc/servdb.conf
copy etc/datasetdb.conf to /usr/local/nagiosgraph/etc/datasetdb.conf
copy etc/rrdopts.conf to /usr/local/nagiosgraph/etc/rrdopts.conf
copy etc/nagiosgraph.conf to /usr/local/nagiosgraph/etc/nagiosgraph.conf
copy etc/nagiosgraph_es.conf to /usr/local/nagiosgraph/etc/nagiosgraph_es.conf
copy etc/access.conf to /usr/local/nagiosgraph/etc/access.conf
copy etc/nagiosgraph_fr.conf to /usr/local/nagiosgraph/etc/nagiosgraph_fr.conf
copy etc/labels.conf to /usr/local/nagiosgraph/etc/labels.conf
copy etc/hostdb.conf to /usr/local/nagiosgraph/etc/hostdb.conf
copy etc/map to /usr/local/nagiosgraph/etc/map
copy etc/ngshared.pm to /usr/local/nagiosgraph/etc
replace text in /usr/local/nagiosgraph/etc/nagiosgraph.conf
move /usr/local/nagiosgraph/etc/nagiosgraph.conf-bak to /usr/local/nagiosgraph/etc/nagiosgraph.conf
replace text in /usr/local/nagiosgraph/etc/nagiosgraph.conf
move /usr/local/nagiosgraph/etc/nagiosgraph.conf-bak to /usr/local/nagiosgraph/etc/nagiosgraph.conf
write stub to /usr/local/nagiosgraph/etc/nagiosgraph-nagios.cfg
write stub to /usr/local/nagiosgraph/etc/nagiosgraph-commands.cfg
write stub to /usr/local/nagiosgraph/etc/nagiosgraph-apache.conf
mkdir /usr/local/nagiosgraph/cgi
copy cgi/showservice.cgi to /usr/local/nagiosgraph/cgi
replace text in /usr/local/nagiosgraph/cgi/showservice.cgi
move /usr/local/nagiosgraph/cgi/showservice.cgi-bak to /usr/local/nagiosgraph/cgi/showservice.cgi
chmod 755 on /usr/local/nagiosgraph/cgi/showservice.cgi
copy cgi/showgraph.cgi to /usr/local/nagiosgraph/cgi
replace text in /usr/local/nagiosgraph/cgi/showgraph.cgi
move /usr/local/nagiosgraph/cgi/showgraph.cgi-bak to /usr/local/nagiosgraph/cgi/showgraph.cgi
chmod 755 on /usr/local/nagiosgraph/cgi/showgraph.cgi
copy cgi/showgroup.cgi to /usr/local/nagiosgraph/cgi
replace text in /usr/local/nagiosgraph/cgi/showgroup.cgi
move /usr/local/nagiosgraph/cgi/showgroup.cgi-bak to /usr/local/nagiosgraph/cgi/showgroup.cgi
chmod 755 on /usr/local/nagiosgraph/cgi/showgroup.cgi
copy cgi/showconfig.cgi to /usr/local/nagiosgraph/cgi
replace text in /usr/local/nagiosgraph/cgi/showconfig.cgi
move /usr/local/nagiosgraph/cgi/showconfig.cgi-bak to /usr/local/nagiosgraph/cgi/showconfig.cgi
chmod 755 on /usr/local/nagiosgraph/cgi/showconfig.cgi
copy cgi/testcolor.cgi to /usr/local/nagiosgraph/cgi
replace text in /usr/local/nagiosgraph/cgi/testcolor.cgi
move /usr/local/nagiosgraph/cgi/testcolor.cgi-bak to /usr/local/nagiosgraph/cgi/testcolor.cgi
chmod 755 on /usr/local/nagiosgraph/cgi/testcolor.cgi
copy cgi/showhost.cgi to /usr/local/nagiosgraph/cgi
replace text in /usr/local/nagiosgraph/cgi/showhost.cgi
move /usr/local/nagiosgraph/cgi/showhost.cgi-bak to /usr/local/nagiosgraph/cgi/showhost.cgi
chmod 755 on /usr/local/nagiosgraph/cgi/showhost.cgi
copy cgi/show.cgi to /usr/local/nagiosgraph/cgi
replace text in /usr/local/nagiosgraph/cgi/show.cgi
move /usr/local/nagiosgraph/cgi/show.cgi-bak to /usr/local/nagiosgraph/cgi/show.cgi
chmod 755 on /usr/local/nagiosgraph/cgi/show.cgi
mkdir /usr/local/nagiosgraph/bin
copy lib/insert.pl to /usr/local/nagiosgraph/bin
replace text in /usr/local/nagiosgraph/bin/insert.pl
move /usr/local/nagiosgraph/bin/insert.pl-bak to /usr/local/nagiosgraph/bin/insert.pl
chmod 755 on /usr/local/nagiosgraph/bin/insert.pl
mkdir /usr/local/nagiosgraph/share
copy share/nagiosgraph.css to /usr/local/nagiosgraph/share/nagiosgraph.css
copy share/nagiosgraph.js to /usr/local/nagiosgraph/share
mkdir /usr/local/nagiosgraph/doc
copy AUTHORS to /usr/local/nagiosgraph/doc
copy CHANGELOG to /usr/local/nagiosgraph/doc
copy INSTALL to /usr/local/nagiosgraph/doc
copy README to /usr/local/nagiosgraph/doc
copy TODO to /usr/local/nagiosgraph/doc
mkdir /usr/local/nagiosgraph/examples
copy examples/nagiosgraph-commands.cfg to /usr/local/nagiosgraph/examples
copy examples/map_minimal to /usr/local/nagiosgraph/examples
copy examples/map_1_4_4 to /usr/local/nagiosgraph/examples
copy examples/nagiosgraph-nagios.cfg to /usr/local/nagiosgraph/examples
copy examples/map_1_4_3 to /usr/local/nagiosgraph/examples
copy examples/nagiosgraph.1.css to /usr/local/nagiosgraph/examples
copy examples/nagiosgraph-logrotate to /usr/local/nagiosgraph/examples
copy examples/map_mwall to /usr/local/nagiosgraph/examples
copy examples/map_1_3 to /usr/local/nagiosgraph/examples
copy examples/map_examples to /usr/local/nagiosgraph/examples
copy examples/nagiosgraph.2.css to /usr/local/nagiosgraph/examples
copy examples/nagiosgraph-apache.conf to /usr/local/nagiosgraph/examples
copy share/graph.gif to /usr/local/nagiosgraph/examples
copy share/nagiosgraph.ssi to /usr/local/nagiosgraph/examples
mkdir /usr/local/nagiosgraph/util
copy utils/testentry.pl to /usr/local/nagiosgraph/util
copy utils/upgrade.pl to /usr/local/nagiosgraph/util
chmod 755 on /usr/local/nagiosgraph/util/testentry.pl
chmod 755 on /usr/local/nagiosgraph/util/upgrade.pl
mkdir /usr/local/nagiosgraph/var/rrd
chmod 755 on /usr/local/nagiosgraph/var/rrd
chown nagios,- on /usr/local/nagiosgraph/var/rrd
touching /usr/local/nagiosgraph/var/nagiosgraph.log
chmod 644 on /usr/local/nagiosgraph/var/nagiosgraph.log
chown nagios,- on /usr/local/nagiosgraph/var/nagiosgraph.log
touching /usr/local/nagiosgraph/var/nagiosgraph-cgi.log
chmod 644 on /usr/local/nagiosgraph/var/nagiosgraph-cgi.log
chown www-data,- on /usr/local/nagiosgraph/var/nagiosgraph-cgi.log

  To complete the installation, do the following:

  * In the nagios configuration file (e.g. nagios.cfg),
    add these lines:

# process nagios performance data using nagiosgraph
process_performance_data=1
service_perfdata_file=/tmp/perfdata.log
service_perfdata_file_template=$LASTSERVICECHECK$||$HOSTNAME$||$SERVICEDESC$||$SERVICEOUTPUT$||$SERVICEPERFDATA$
service_perfdata_file_mode=a
service_perfdata_file_processing_interval=30
service_perfdata_file_processing_command=process-service-perfdata-for-nagiosgraph


  * In the nagios commands file (e.g. command.cfg),
    add these lines:

# command to process nagios performance data for nagiosgraph
define command {
  command_name process-service-perfdata-for-nagiosgraph
  command_line /usr/local/nagiosgraph/bin/insert.pl
}


  * In the apache configuration file (e.g. httpd.conf),
    add this line:

include /usr/local/nagiosgraph/etc/nagiosgraph-apache.conf

  * Restart nagios to start data collection:

/etc/init.d/nagios restart

  * Restart apache to enable display of graphs:

/etc/init.d/apache restart

  * To enable graph links and mouseovers, see README sections:
       Displaying Per-Service and Per-Host Graph Icons and Links
       Displaying Graphs in Nagios Mouseovers

root@ubuntu:/tmp/nagiosgraph-1.4.4#
#+end_example
** DONE nagios3: Error: Unable to create temp file for writing status data
  CLOSED: [2016-06-20 Mon 09:48]
root@kitchen-mdm-app-nocache-node1:/var/log/nagios3# grep -R status_file /etc/nagios3/
/etc/nagios3/nagios.cfg:status_file=/var/cache/nagios3/status.dat

#+BEGIN_EXAMPLE
root@kitchen-mdm-app-nocache-node1:/var/log/nagios3# tail -f nagios.log
tail -f nagios.log
[1466387202] Error: Unable to create temp file for writing status data: No such file or directory
[1466387212] Error: Unable to create temp file for writing status data: No such file or directory
[1466387222] Error: Unable to create temp file for writing status data: No such file or directory
[1466387232] Error: Unable to create temp file for writing status data: Permission denied
[1466387247] Caught SIGTERM, shutting down...
#+END_EXAMPLE
** # --8<-------------------------- separator ------------------------>8--
** DONE Nagios checks for service status
  CLOSED: [2014-07-21 Mon 10:24]
http://serverfault.com/questions/387859/generic-nagios-plugin-to-check-if-a-specific-process-service-is-running
/usr/lib/nagios/plugins/check_procs -c 1: -w 3: -C sshd
** DONE nagios get current check list for a server: cat /etc/nagios3/conf.d/localhost_nagios2.cfg
  CLOSED: [2014-07-22 Tue 09:47]
#+begin_example
root@ubuntu:~# cat /etc/nagios3/conf.d/localhost_nagios2.cfg
# A simple configuration file for monitoring the local host
# This can serve as an example for configuring other servers;
# Custom services specific to this host are added here, but services
# defined in nagios2-common_services.cfg may also apply.
#

define host{
        use                     generic-host            ; Name of host template to use
        host_name               localhost
        alias                   localhost
        address                 127.0.0.1
        }

# Define a service to check the disk space of the root partition
# on the local machine.  Warning if < 20% free, critical if
# < 10% free space on partition.

define service{
        use                             generic-service         ; Name of service template to use
        host_name                       localhost
        service_description             Disk Space
        check_command                   check_all_disks!20%!10%
        }



# Define a service to check the number of currently logged in
# users on the local machine.  Warning if > 20 users, critical
# if > 50 users.

define service{
        use                             generic-service         ; Name of service template to use
        host_name                       localhost
        service_description             Current Users
        check_command                   check_users!20!50
        }


# Define a service to check the number of currently running procs
# on the local machine.  Warning if > 250 processes, critical if
# > 400 processes.

define service{
        use                             generic-service         ; Name of service template to use
        host_name                       localhost
        service_description             Total Processes
		check_command                   check_procs!250!400
        }



# Define a service to check the load on the local machine.

define service{
        use                             generic-service         ; Name of service template to use
        host_name                       localhost
        service_description             Current Load
		check_command                   check_load!5.0!4.0!3.0!10.0!6.0!4.0
        }
#+end_example
** DONE Get nagios alerts: notify-service-by-email
  CLOSED: [2014-07-22 Tue 11:14]
cat /etc/nagios3/commands.cfg
cat /etc/nagios3/conf.d/contacts_nagios2.cfg

command_line	/usr/bin/printf "%b" "***** Nagios *****\n\nNotification Type: $NOTIFICATIONTYPE$\n\nService: $SERVICEDESC$\nHost: $HOSTALIAS$\nAddress: $HOSTADDRESS$\nState: $SERVICESTATE$\n\nDate/Time: $LONGDATETIME$\n\nAdditional Info:\n\n$SERVICEOUTPUT$\n" >> /tmp/nagios_service.log


$SERVICEDESC$
$HOSTADDRESS$
$SERVICEOUTPUT$
*** cat /etc/nagios3/conf.d/contacts_nagios2.cfg
#+begin_example
root@ubuntu:/etc/nagios3# cat /etc/nagios3/conf.d/contacts_nagios2.cfg
###############################################################################
# contacts.cfg
###############################################################################



###############################################################################
###############################################################################
#
# CONTACTS
#
###############################################################################
###############################################################################

# In this simple config file, a single contact will receive all alerts.

define contact{
        contact_name                    root
        alias                           Root
        service_notification_period     24x7
        host_notification_period        24x7
        service_notification_options    w,u,c,r
        host_notification_options       d,r
        service_notification_commands   notify-service-by-email
        host_notification_commands      notify-host-by-email
        email                           root@localhost
        }



###############################################################################
###############################################################################
#
# CONTACT GROUPS
#
###############################################################################
###############################################################################

# We only have one contact in this simple configuration file, so there is
# no need to create more than one contact group.

define contactgroup{
        contactgroup_name       admins
        alias                   Nagios Administrators
        members                 root
        }
#+end_example
** DONE nagios see configuration: GUI --> configuration
   CLOSED: [2014-07-22 Tue 14:18]
** DONE by default, nagios won't send notification when check fails continuously
  CLOSED: [2014-07-22 Tue 14:51]
sed -i 's/notification_interval           0/notification_interval           1/g' /etc/nagios3/conf.d/generic-service_nagios2.cfg
** DONE get nagios alert history: cat /var/log/nagios3/nagios.log |  grep -i alert
   CLOSED: [2014-07-22 Tue 14:54]
** DONE nagios get trends history data for one servic check: nagios retention file
  CLOSED: [2014-07-22 Tue 15:25]
/var/lib/nagios3/retention.dat
http://comments.gmane.org/gmane.network.nagios.user/69408
** DONE mk-livestatus 1.1.6p1 fails to compile on Ubuntu 12.04
  CLOSED: [2014-07-22 Tue 16:16]
The TableLog.cc was missing the "stddef.h" include file which defines the offsetof() macro.

Simply add
#include <stddef.h>
To the beginning of TableLog.cc
http://stackoverflow.com/questions/19568742/mk-livestatus-1-1-6p1-fails-to-compile-on-ubuntu-12-04-precise
#+begin_example

0
down vote
favorite
When trying to compile CheckMK's livestatus Nagios plugin, I get an error during the "make" process:

g++ -DHAVE_CONFIG_H -I. -I..    -I../nagios -fPIC -g -O2 -MT livestatus_so-TableLog.o -MD -MP -MF .deps/livestatus_so-TableLog.Tpo -c -o livestatus_so-TableLog.o `test -f 'TableLog.cc' || echo './'`TableLog.cc
TableLog.cc: In member function 'void TableLog::updateLogfileIndex()':
TableLog.cc:250:21: error: expected primary-expression before 'struct'
TableLog.cc:250:36: error: 'd_name' was not declared in this scope
TableLog.cc:250:42: error: 'offsetof' was not declared in this scope
make[2]: *** [livestatus_so-TableLog.o] Error 1
The relevant part of TableLog.cc:

250         int len = offsetof(struct dirent, d_name)
251             + pathconf(log_archive_path, _PC_NAME_MAX) + 1;
#+end_example
** DONE [#A] mk-livestatus
  CLOSED: [2014-07-22 Tue 16:50]
http://mathias-kettner.de/checkmk_livestatus.html
mkdir /var/lib/nagios/rw/

chmod 777 /var/lib/nagios/rw/

echo 'GET hosts' | unixcat /var/lib/nagios/rw/live

echo 'GET statehist' | unixcat /var/lib/nagios/rw/live

echo 'GET contacts\nColumns: name alias' | unixcat /var/lib/nagios/rw/live

GET services
Columns: host_name description state
Filter: state = 2
*** get history status
echo 'GET statehist
Columns: host_name service_description state duration duration_part
Filter: service_description = Total Processes3' | unixcat /var/lib/nagios/rw/live
*** services.py: get current status
python ./services.py
#+begin_example
root@ubuntu:/home/denny/check_mk# cat services.py
#!/usr/bin/python
#
# Sample program for accessing the Livestatus Module
# from a python program
socket_path = "/var/lib/nagios/rw/live"

import socket
s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
s.connect(socket_path)

# Write command to socket
s.send("GET services\nColumns: host_name description state\n")

# Important: Close sending direction. That way
# the other side knows we are finished.
s.shutdown(socket.SHUT_WR)

# Now read the answer
answer = s.recv(100000000)

# Parse the answer into a table (a list of lists)
table = [ line.split(';') for line in answer.split('\n')[:-1] ]

print table
#+end_example
*** useful link
http://serverfault.com/questions/564358/query-nagios-status-programmatically
http://mathias-kettner.com/checkmk_livestatus.html
** DONE [#A] How to extend Nagios for custom monitoring
  CLOSED: [2014-07-23 Wed 13:14]
Every valid Nagios check from a plugin has to produce a numeric exit status. Possible statuses are:

0 – Everything is OK and the check completed successfully.
1 – The resource is in warning state. Something is not quite right.
2 – The resource is in critical state. A host may be down or a service not running.
3 – Unknown state, which does not necessarily indicate a problem, but rather shows that the check cannot give a clear, unambiguous status.

http://www.openlogic.com/wazi/bid/256126/How-to-extend-Nagios-for-custom-monitoring
http://nagios.sourceforge.net/docs/3_0/macros.html
** [#B] How check is implemented: /etc/nagios/nrpe.cfg
** ls /usr/lib/nagios/plugins
#+begin_example
root@fluig-id-cdn-01:~# ls /usr/lib/nagios/plugins
ls /usr/lib/nagios/plugins
adsync_arg.py        check_icmp            check_nntp       check_snmp
check_ad_arg         check_ide_smart       check_nntps      check_spop
check_apt            check_ifoperstatus    check_nrpe       check_ssh
check_bgpstate       check_ifstatus        check_nt         check_ssmtp
check_breeze         check_imap            check_ntp        check_swap
check_by_ssh         check_ircd            check_ntp_peer   check_tcp
check_clamd          check_jabber          check_ntp_time   check_time
check_cluster        check_ldap            check_nwstat     check_udp
check_dhcp           check_ldaps           check_oracle     check_ups
check_dig            check_linux_raid      check_overcr     check_users
check_disk           check_linux_stats.pl  check_pgsql      check_wave
check_disk_smb       check_load            check_ping       insert.pl
check_dns            check_log             check_pop        insert.sh
check_dummy          check_logfiles        check_procs      negate
check_file_age       check_mailq           check_radius     nohup.out
check_flexlm         check_mrtg            check_real       urlize
check_ftp            check_mrtgtraf        check_rpc        utils.pm
check_helloworld.py  check_mysql           check_rta_multi  utils.sh
check_host           check_mysql_query     check_sensors
check_hpjd           check_nagios          check_simap
check_http           check_nfs4.pl         check_smtp
root@fluig-id-cdn-01:~#
#+end_example
** DONE [#B] nagios service check. Status Information: (null): file privilege issue
  CLOSED: [2014-07-30 Wed 15:50]
#+begin_example
mac@ubuntu:/home/denny/devop/fluig-metric$  /home/denny/devop/fluig-metric/code/nagios_virtual_checks/nagios_plugin/check_fluig_status.sh all
-bash: /home/denny/devop/fluig-metric/code/nagios_virtual_checks/nagios_plugin/check_fluig_status.sh: Permission denied
mac@ubuntu:/home/denny/devop/fluig-metric$  chmod o+x /home/denny/devop/fluig-metric/code/nagios_virtual_checks/nagios_plugin/check_fluig_status.sh
mac@ubuntu:/home/denny/devop/fluig-metric$  /home/denny/devop/fluig-metric/code/nagios_virtual_checks/nagios_plugin/check_fluig_status.sh all
-bash: /home/denny/devop/fluig-metric/code/nagios_virtual_checks/nagios_plugin/check_fluig_status.sh: Permission denied

mac@ubuntu:/home/denny/devop/fluig-metric$ ls -lth  /home/denny/devop/fluig-metric/code/nagios_virtual_checks/nagios_plugin/check_fluig_status.sh
-rw-rw-r-x 1 mac mac 520 Jul 30 13:41 /home/denny/devop/fluig-metric/code/nagios_virtual_checks/nagios_plugin/check_fluig_status.sh
mac@ubuntu:/home/denny/devop/fluig-metric$ sudo chmod 777 /home/denny/devop/fluig-metric/code/nagios_virtual_checks/nagios_plugin/check_fluig_status.sh
mac@ubuntu:/home/denny/devop/fluig-metric$ ls -lth  /home/denny/devop/fluig-metric/code/nagios_virtual_checks/nagios_plugin/check_fluig_status.sh
-rwxrwxrwx 1 mac mac 520 Jul 30 13:41 /home/denny/devop/fluig-metric/code/nagios_virtual_checks/nagios_plugin/check_fluig_status.sh
mac@ubuntu:/home/denny/devop/fluig-metric$  /home/denny/devop/fluig-metric/code/nagios_virtual_checks/nagios_plugin/check_fluig_status.sh all
Traceback (most recent call last):
  File "/home/denny/devop/fluig-metric/code/nagios_virtual_checks/nagios_plugin/check_fluig_status.py", line 18, in <module>
    Rthandler = RotatingFileHandler('/var/log/check_fluig_status.log', maxBytes=5*1024*1024,backupCount=5)
  File "/usr/lib/python2.7/logging/handlers.py", line 118, in __init__
    BaseRotatingHandler.__init__(self, filename, mode, encoding, delay)
  File "/usr/lib/python2.7/logging/handlers.py", line 65, in __init__
    logging.FileHandler.__init__(self, filename, mode, encoding, delay)
  File "/usr/lib/python2.7/logging/__init__.py", line 897, in __init__
    StreamHandler.__init__(self, self._open())
  File "/usr/lib/python2.7/logging/__init__.py", line 916, in _open
    stream = open(self.baseFilename, self.mode)
IOError: [Errno 13] Permission denied: '/var/log/check_fluig_status.log'
#+end_example
** DONE CHECK_NRPE: Socket timeout after 10 seconds
  CLOSED: [2014-07-30 Wed 18:32]
http://172.20.16.13/cgi-bin/nagios3/extinfo.cgi?type=2&host=fluig-id-cdn-01&service=check_ad_account
fluig-id-cdn-01 --> check_ad_account

vim /etc/nagios3/nagios-plugins/config/check_nrpe.cfg

,-----------
| # this command runs a program $ARG1$ with no arguments
| define command {
| 	command_name	check_nrpe
| 	command_line	/usr/lib/nagios/plugins/check_nrpe -H $HOSTADDRESS$ -c $ARG1$
| }
`-----------


,-----------
| # this command runs a program $ARG1$ with no arguments
| define command {
| 	command_name	check_nrpe
| 	command_line	/usr/lib/nagios/plugins/check_nrpe -H $HOSTADDRESS$ -c $ARG1$ -t 20
| }
`-----------
** DONE Main Configuration File Options for nagios
  CLOSED: [2014-07-28 Mon 16:00]
http://nagios.sourceforge.net/docs/3_0/configmain.html
** DONE [#B] NRPE: Unable to read output: /usr/lib/nagios/plugins/check_nrpe -H 127.0.0.1 -c check_ad_account
  CLOSED: [2014-08-01 Fri 10:36]
root@fluig-id-cdn-01:~# /usr/lib/nagios/plugins/check_nrpe -H 127.0.0.1 -c check_ad_account
NRPE: Unable to read output

This service has 1 comment associated with it	This service is flapping between states	Perform Extra Service Actions
WARNING	2014-07-31 21:35:36	 0d 0h 42m 24s	4/4	NRPE: Unable to read output

#+begin_example
root@fluig-id-cdn-01:~# /usr/lib/nagios/plugins/check_nrpe -H 127.0.0.1 -c check_ad_account -t 20
<r/lib/nagios/plugins/check_nrpe -H 127.0.0.1 -c check_ad_account -t 20
Unexpected error: <class 'selenium.common.exceptions.WebDriverException'>
CRITICAL: ADSYNC TEST Failed. Username is fluigid.sp@totvs.com.br | seconds=0.000
root@fluig-id-cdn-01:~# ps -ef | grep firefox
ps -ef | grep firefox
root      4236     1  0 Jul24 ?        00:38:55 /usr/lib/firefox/firefox
root     17186     1  1 14:49 ?        00:00:05 /usr/lib/firefox/firefox -foreground
root     19903 17948  0 14:57 pts/6    00:00:00 grep --color=auto firefox
nagios   22680     1  0 Jul30 ?        00:00:23 /usr/lib/firefox/firefox -silent
#+end_example
** DONE Nagiosgraph: history of service_status. for localhost check: add to
  CLOSED: [2014-08-01 Fri 18:11]
http://172.20.16.13/nagiosgraph/cgi-bin/show.cgi?host=localhost&service=ad_service_status

#+begin_Example
define service{
        use                             generic-service,graphed-service         ; Name of service template to use
        host_name                       localhost
        service_description             couchbase_service_status
        check_command                   check_fluig_status!couchbase
        }
#+end_example
** DONE [#B] Don't send alerts for localhost: Disable event handler for this host
   CLOSED: [2014-08-01 Fri 16:58]
** DONE [#B] No alerts is sent for one nagios check: flapped service
  CLOSED: [2014-08-01 Fri 18:13]
check_ad_account
http://172.20.16.13/cgi-bin/nagios3/extinfo.cgi?type=2&host=fluig-id-cdn-01&service=check_ad_account
#+begin_example
2014-08-01 18:35:06	(Nagios Process)	Notifications for this service are being suppressed because it was detected as having been flapping between different states (20.7% change >= 20.0% threshold). When the service state stabilizes and the flapping stops, notifications will be re-enabled.	404	No	Flap Detection	N/A	Delete This Comment
#+end_example
** TODO Nagios how to get the rrdfile for a given check
/usr/lib/nagios/plugins/check_nrpe -H 172.20.16.16 -c check_SEARCH
** TODO [#A] Some rrdfile is not updated promptly: workaround is remove rrdfile, restart nagios-nrpe-server, then wait
** DONE centos install nagios
  CLOSED: [2014-09-12 Fri 23:54]
/etc/init.d/nagios status
/etc/init.d/nrpe status
** [#A] nagios debug for fail to start
nagios -v /etc/nagios/nagios.cfg

/usr/sbin/nagios3 -v /etc/nagios3/nagios.cfg
** # --8<-------------------------- separator ------------------------>8--
** DONE check_MEMORY and check_NETWORK: Can't locate Sys/Statistics/Linux.pm
  CLOSED: [2014-10-06 Mon 11:23]
http://viewsby.wordpress.com/2014/02/20/perl-nagios-cant-locate-sysstatisticslinux-pm-in-inc/
apt-get install libsys-statistics-linux-perl
yum install perl-Sys-Statistics-Linux

#+begin_example
root@denny-chef-Ubuntu-09:/etc/nagios3/conf.d# /usr/lib/nagios/plugins/check_nrpe -H 127.0.0.1 -c check_MEMORY
NRPE: Unable to read output
root@denny-chef-Ubuntu-09:/etc/nagios3/conf.d# /usr/lib/nagios/plugins/check_nrpe -H 127.0.0.1 -c check_MEMORY
NRPE: Unable to read output
#+end_example

#+begin_example
root@denny-chef-Ubuntu-09:/etc/nagios3/conf.d# /usr/lib/nagios/plugins/check_linux_stats.pl -M -w 95,90 -c 100,95
Can't locate Sys/Statistics/Linux.pm in @INC (@INC contains: /usr/lib/nagios/plugins /etc/perl /usr/local/lib/perl/5.14.2 /usr/local/share/perl/5.14.2 /usr/lib/perl5 /usr/share/perl5 /usr/lib/perl/5.14 /usr/share/perl/5.14 /usr/local/lib/site_perl .) at /usr/lib/nagios/plugins/check_linux_stats.pl line 35.
BEGIN failed--compilation aborted at /usr/lib/nagios/plugins/check_linux_stats.pl line 35.
root@denny-chef-Ubuntu-09:/etc/nagios3/conf.d# /usr/lib/nagios/plugins/check_linux_stats.pl -N -w 100000000 -c 150000000 -p eth0
Can't locate Sys/Statistics/Linux.pm in @INC (@INC contains: /usr/lib/nagios/plugins /etc/perl /usr/local/lib/perl/5.14.2 /usr/local/share/perl/5.14.2 /usr/lib/perl5 /usr/share/perl5 /usr/lib/perl/5.14 /usr/share/perl/5.14 /usr/local/lib/site_perl .) at /usr/lib/nagios/plugins/check_linux_stats.pl line 35.
BEGIN failed--compilation aborted at /usr/lib/nagios/plugins/check_linux_stats.pl line 35.
#+end_example
** DONE Install check_logfiles plugin
  CLOSED: [2014-10-06 Mon 18:24]
/usr/lib/nagios/plugins/check_logfiles -f /etc/nagios/log_cfg/search_log.cfg
#+begin_example
root@fluig-id-cdn-01:~# cat /usr/lib/nagios/plugins/check_logfiles
cat /usr/lib/nagios/plugins/check_logfiles
#! /usr/bin/perl -w
# nagios: -epn
#
# Logfile::Config::Tivoli.pm - Tivoli Config Module
#
# Purpose: Provide a convenient way for loading
#          tivoli config files and
#          return it as hash structure
#
package Nagios::Tivoli::Config::Logfile;

use strict;

sub new {
  my($this, $param ) = @_;
  my $class = ref($this) || $this;

  my $self = {
      formatfile   => '',  # format file with tivoli format definitions,
                           # can be an array of files
      formatstring => '',  # format file content as string
      severity_mappings => {},
      max_continuation_lines => 0, # in case there are %n in among the patterns
      line_buffer => [],   # for continuation lines
      line_buffer_size => 0,
  };
  bless $self, $class;

  $self->set_severity_mapping('fatal', 2);
  $self->set_severity_mapping('critical', 2);
  $self->set_severity_mapping('severe', 2);
  $self->set_severity_mapping('warning', 1);
  $self->set_severity_mapping('minor', 1);
  $self->set_severity_mapping('harmless', 0);
  $self->set_severity_mapping('unknown', 0);

  # parse parameter
  if (ref($param) eq "HASH") {
    for my $key (keys %{$param}) {
      if (!defined $self->{lc $key}) {
        printf STDERR "unrecognized parameter: %s\n", $key;
        return undef;
      } else {
        if (ref($param->{$key}) eq 'HASH') {
          $self->merge_hash($self->{$key}, $param->{$key});
        } else {
          $self->{lc $key} = $param->{$key};
        }
      }
    }
  } elsif (ref($param) eq "") {
    $self->{formatfile} = $param;
  } else {
    printf STDERR "formatfile is a required parameter\n";
  }
  if ((!defined $self->{formatfile} || $self->{formatfile} eq '') &&
      (!defined $self->{formatstring} || $self->{formatstring} eq '')) {
        printf STDERR "please either specify formatfile or formatstring\n";
    return undef;
  }
  if (defined $self->{formatstring} and $self->{formatstring} ne '') {
    $self->{_formatstring} = $self->{formatstring};
  } else {
    $self->{_formatstring} = $self->_read($self->{formatfile});
  }
  if (! $self->{_formatstring}) {
    return undef;
  }
  foreach (keys %{$self->{tivolimapping}}) {
    $self->set_severity_mapping($_, $self->{tivolimapping}->{$_});
  }
  if ($self->_parse) {
    #Data::Dumper::Dumper($self->{formats});
    return $self;
  } else {
    printf STDERR ("parsing failed, see previous messages...");
    return undef;
  }
}

sub _read {
  my $self     = shift;
  my $filename = shift;
  my $content;
  if (ref($filename) eq 'ARRAY') {
    for my $file (@{$filename}) {
      $content .= $self->_read($file);
    }
  } else {
    if (open FMT, $filename) {
      while(<FMT>) {
        $content .= $_;
      }
      close FMT;
    } else {
      printf STDERR "unable to read file %s: %s\n", $filename, $!;
      return undef;
    }
  }
  return($content);
}

sub _parse {
  my $self = shift;
  my $format;
  my $lineno = 0;
  for my $line (split /\n/, $self->{_formatstring}) {
    $lineno++;
    chomp $line;
    $line = $1 if $line =~ /^\s*(.*?)\s*$/;

    next if $line =~ m/^\/\//;
    next if $line eq "";

    if ($line =~ m/^FORMAT/) {
      my($name, $follows, $followname) =
          $line =~ m/^FORMAT\s+(.*?)\s*(|FOLLOWS\s+(.*?))$/;
      $format= Nagios::Tivoli::Config::Logfile::Format->new({
          name => $name,
          lineno => $lineno,
          severity_mappings => $self->{severity_mappings},
      });
      if (defined $followname) {
        my @follows = split /\s*,\s*/, $followname;
        for my $follow (@follows) {
          if (my $follow_format = $self->get_format_by_name($follow)) {
            $format->inherit($follow_format);
          }
        }
        $format->{follows} = \@follows;
      }
    } elsif ($line =~ m/^END/) {
      if (!defined $format) {
        printf STDERR "found format end without beginning\n";
        return 0;
      }
      if (!defined $format->{pattern}) {
        if (!exists $format->{follows}) {
          printf STDERR "found format without pattern\n";
          return 0;
        }
      }
      $self->add_format($format);
    } elsif (defined $format) {
      if (!defined $format->{pattern}) {
        # %s Specifies a variable string.
        # %t Specifies a variable date of the form 'MMM DD hh:mm:ss'
        # %s+ Specifies one or more variable strings that
        #     are separated by spaces.
        # %s* Specifies zero or more strings separated by white space.
        # %n Specifies a new line (CR).
        #    This applies only to the following adapters:
        #    tecad_logfile_aix4-r1, tecad_logfile_hpux10,
        #    tecad_logfile_linux_ix86, tecad_logfile_linux-ppc,
        #    tecad_logfile_linux-s390, tecad_logfile_solaris2,
        #    and tecad_win.
        $format->{tiv_pattern} = $line;
        $format->{patternlines} = 0;
        if ($line =~ /%n/) {
          $format->{patternlines}++ while $line =~ /%n/g;
          $format->{pattern} = [map { $self->translate_pattern($_) } split /%n/, $line];
          $self->{max_continuation_lines} = $format->{patternlines} unless
              $format->{patternlines} <= $self->{max_continuation_lines};
        } else {
          $format->{pattern} = $self->translate_pattern($line);
        }
      } elsif ($line =~ m/^-(.*?)\s+(.*)$/i) {
        $format->add_variable($1, $2);
      } elsif ($line =~ m/^(.*?)\s+"*(.*?)"*\s*$/) {
        $format->add_slot($1, $2);
      }
    } else {
      printf STDERR "%s is outside of a format definition\n", $line;
      return 0;
    }
  }
  return 1;
}

sub translate_pattern {
  my $self = shift;
  my $tiv_pattern = shift;
  $tiv_pattern =~ s/\\/\\\\/g;          # quote \
  $tiv_pattern =~ s/\(/\\(/g;           # quote (
  $tiv_pattern =~ s/\)/\\)/g;           # quote )
  $tiv_pattern =~ s/%\[\d+\]s/%s/g;     # replace %[2]s with just %s
  $tiv_pattern =~ s/\[/\\[/g;           # quote [
  $tiv_pattern =~ s/\]/\\]/g;           # quote ]
  $tiv_pattern =~ s/\?/\\?/g;           # quote ?
  $tiv_pattern =~ s/\|/\\|/g;           # quote |
  $tiv_pattern =~ s/\-/\\-/g;           # quote -
  #$tiv_pattern =~ s/%s\+/\(.+?\)/g;     # %s+  becomes .+?
  #$tiv_pattern =~ s/%s\*/\(.*?\)/g;     # %s*  becomes .*?
  #$tiv_pattern =~ s/%s/\(\[^\\s\]+?\)/g;  # %s   becomes [^\s]+?
  $tiv_pattern =~ s/%s\+/\([^\\s]*?.+[^\\s]*?\)/g; # %s+ becomes [^\s]*?.+[^\s]*?
  $tiv_pattern =~ s/%s\*\s*$/\(.*\)/g;     # last %s*  becomes .* eats the rest
  $tiv_pattern =~ s/%s\*/\(.*?\)/g;     # %s*  becomes .*? eats as much as necessary
  $tiv_pattern =~ s/%s/\(\[^\\s\]+\)/g;  # %s   becomes [^\s]+?
  #$tiv_pattern =~ s/%n/\\n/g;           # %n   becomes \n
  $tiv_pattern =~ s/[ ]+/\\s\+/g;           # blanks become \s+
  $tiv_pattern =~ s/%n//g;           # %n   becomes \n
  $tiv_pattern =~ s/%t/\(\\w\{3\}\\s+\\d\{1,2\}\\s+\\d\{1,2\}\:\\d\{1,2\}\:\\d\{1,2\}\)/g;
  return $tiv_pattern;
}

sub match {
  my $self = shift;
  my $line = shift;
  if ($self->{line_buffer_size} < $self->{max_continuation_lines} + 1) {
    push(@{$self->{line_buffer}}, $line);
    $self->{line_buffer_size}++;
  } else {
    shift @{$self->{line_buffer}};
    push(@{$self->{line_buffer}}, $line);
  }
#printf STDERR "try: %s\n", $line;
  foreach my $format (reverse @{$self->{'formats'}}) {
    if (($format->{name} ne '*DISCARD*') &&
        (! $format->has_slots() || ! $format->get_slot('severity'))) {
      next; # ungueltiges format
    }
    my @matches = ();
#printf STDERR "format %s\n", $format->{name};
#printf STDERR "match /%s/\n", $format->{pattern};
    if (my @matches = $self->match_pattern($line, $format->{pattern})) {
      my $hit = Nagios::Tivoli::Config::Logfile::Hit->new({
          format => $format,
          logline => $line,
          matches => \@matches,
          format_mappings => $self->{format_mappings},
          severity_mappings => $self->{severity_mappings},
      });
#printf STDERR "hit: %s\n", $line;
      if ($format->{name} eq '*DISCARD*') {
#printf STDERR "discard: %s %s\n", $line, Data::Dumper::Dumper($hit);
        last;
      } else {
#printf STDERR "hit2: %s // %s\n", $hit->{subject}, $format->{name};
        return({
          exit_code   => $hit->get_nagios_severity(),
          severity    => $hit->{severity},
          format_name => $hit->{format_name},
          subject     => $hit->{subject},
          logline     => $line,
          slots       => $hit->{slots},
        });
      }
    }
  }
#printf STDERR "mis: %s\n", $line;
  return({
    exit_code   => $self->get_severity_mapping('HARMLESS'),
    severity    => 'HARMLESS',
    format_name => 'NO MATCHING RULE',
    subject     => 'NO MATCHING RULE',
    logline     => $line,
    slots       => { },
  });
}

sub match_pattern {
  my $self = shift;
  my $line = shift;
  my $pattern = shift;
  if (ref($pattern) eq 'ARRAY') {
    my @all_matches = ();
    #
    my $patterns = scalar(@{$pattern});
    if ($patterns > $self->{line_buffer_size}) {
      # zu wenig zeilen vorhanden
      return ();
    } else {
      my $startidx = $self->{line_buffer_size} - $patterns;
      my $idx = 0;
      while ($idx < $patterns) {
        # pattern[$idx] matched ${$self->{line_buffer}}[$startidx + $idx] ?
        if (my @matches =
            ${$self->{line_buffer}}[$startidx + $idx] =~ /$pattern->[$idx]/) {
          $idx++;
          push(@all_matches, @matches);
        } else {
          last;
        }
      }
      if ($idx == $patterns) {
        return @all_matches;
      } else {
        return ();
      }
    }
  } else {
    my @matches = $line =~ /$pattern/;
    return @matches;
  }
}

# inherit
#
# copy variable and slot definitions of a followed format to the current format
#
sub inherit {
  my $self = shift;
  my $ancestor = shift;
  $self->merge_hash($self->{variables}, $ancestor->{variables});
  $self->merge_hash($self->{slots}, $ancestor->{slots});
}

# get_severity_mapping
#
# get the numerical nagios level for a tivoli level
#
sub get_severity_mapping {
  my $self = shift;
  my $tivoli_severity = lc shift;
  return $self->{severity_mappings}->{$tivoli_severity};
}

# set_severity_mapping
#
# set the numerical nagios level for a tivoli level
#
sub set_severity_mapping {
  my $self = shift;
  my $tivoli_severity = lc shift;
  my $nagios_severity = shift;
  $self->{severity_mappings}->{$tivoli_severity} = $nagios_severity;
}

# set_format_mappings
#
# set runtime values for LABEL, DEFAULT,...
#
sub set_format_mappings {
    my $self = shift;
    my %mappings = @_;
    foreach (keys %mappings) {
      $self->{format_mappings}->{$_} = $mappings{$_};
    }
}

sub add_format {
  my $self = shift;
  my $format = shift;
  push(@{$self->{formats}}, $format);
}

sub get_format_by_name {
  my $self = shift;
  my $name = shift;
  foreach (@{$self->{formats}}) {
    return $_ if $_->{name} eq $name;
  }
  return undef;
}

sub merge_hash {
    my $self  = shift;
    my $hash1 = shift;
    my $hash2 = shift;

    for my $key (keys %{$hash2}) {
        $hash1->{$key} = $hash2->{$key};
    }
    return($hash1);
}


package Nagios::Tivoli::Config::Logfile::Format;

use strict;
use warnings;
use Carp;
use vars qw(@ISA);

@ISA = qw(Nagios::Tivoli::Config::Logfile);

sub new {
  my($this, $param ) = @_;
  my $class = ref($this) || $this;

  my $self = {
      name => '',
      lineno => 0,
      slots => {},
      variables => {},
      severity_mappings => {},
  };
  bless $self, $class;

  if (ref($param) eq "HASH") {
    for my $key (keys %{$param}) {
      if (!defined $self->{lc $key}) {
        carp("unrecognized parameter: $key");
      } else {
        if (ref($param->{$key}) eq 'HASH') {
          $self->merge_hash($self->{$key}, $param->{$key});
        } else {
          $self->{lc $key} = $param->{$key};
        }
      }
    }
  }
  if (!defined $self->{name}) {
    die "please either specify formatfile or formatstring";
  }
  return $self;
}

sub add_slot {
  my $self = shift;
  my $slot = shift;
  my $value = shift;
  $self->{slots}->{$slot} = $value;
}

sub get_slot {
  my $self = shift;
  my $slot = shift;
  return $self->{slots}->{$slot};
}

sub has_slots {
  my $self = shift;
  return scalar (keys %{$self->{slots}});
}

sub add_variable {
  my $self = shift;
  my $variable = shift;
  my $value = shift;
  $self->{variables}->{$variable} = $value;
}

sub get_variable {
  my $self = shift;
  my $variable = shift;
  return $self->{variables}->{$variable};
}

sub has_variables {
  my $self = shift;
  return scalar (keys %{$self->{variables}});
}


package Nagios::Tivoli::Config::Logfile::Hit;

use strict;
use warnings;
use Carp;
use vars qw(@ISA);

@ISA = qw(Nagios::Tivoli::Config::Logfile::Format);

sub new {
  my($this, $param ) = @_;
  my $class = ref($this) || $this;

  my $self = {
      format => $param->{format},
      logline => $param->{logline},
      format_mappings => $param->{format_mappings},
      severity_mappings => $param->{severity_mappings},
      matches => {},
      variables => {},
      slots => {},
  };
  bless $self, $class;
  my $matchcnt = 1;
  map { $self->{matches}->{$matchcnt++} = $_; } @{$param->{matches}};
  $self->init();
  return $self;
}

sub init {
  my $self = shift;
  $self->{severity} = $self->{format}->{slots}->{severity};
  $self->{format_name} = $self->{format}->{name};
  $self->merge_hash($self->{variables}, $self->{format}->{variables});
  $self->merge_hash($self->{slots}, $self->{format}->{slots});
  # resolve pattern groups in internal variables
  foreach my $var (keys %{$self->{variables}}) {
    if ($self->{variables}->{$var} =~ /^\$(\d+)/) {
      if (defined $self->{matches}->{$1}) {
        $self->{variables}->{$var} = $self->{matches}->{$1};
      } else {
        printf STDERR "cannot replace \$%d in var %s\n", $1, $var;
      }
    }
  }
  # resolve pattern groups and format reserved words in slots
  foreach my $slot (keys %{$self->{slots}}) {
    if ($self->{slots}->{$slot} =~ /^\$(\d+)/) {
      if (defined $self->{matches}->{$1}) {
        $self->{slots}->{$slot} = $self->{matches}->{$1};
      } else {
        printf STDERR "cannot replace \$%d in slot %s\n", $1, $slot;
      }
    } elsif ($self->{slots}->{$slot} eq 'DEFAULT') {
      if ($slot eq 'hostname') {
        $self->{slots}->{$slot} = $self->{format_mappings}->{hostname};
      } elsif ($slot eq 'fqhostname') {
        $self->{slots}->{$slot} = $self->{format_mappings}->{fqhostname};
      } elsif ($slot eq 'origin') {
        $self->{slots}->{$slot} = $self->{format_mappings}->{origin};
      } else {
        $self->{slots}->{$slot} = 'check_logfiles';
      }
    } elsif ($self->{slots}->{$slot} eq 'LABEL') {
      $self->{slots}->{$slot} = $self->{format_mappings}->{LABEL};
    } elsif ($self->{slots}->{$slot} eq 'FILENAME') {
      $self->{slots}->{$slot} = $self->{format_mappings}->{FILENAME};
    } else {
    }
  }
  foreach my $slot (keys %{$self->{slots}}) {
    if ($self->{slots}->{$slot} =~ /PRINTF/i) {
      $self->{slots}->{$slot} = $self->printf($self->{slots}->{$slot});
    }
  }
  $self->{subject} = $self->{slots}->{msg} || $self->{logline};
  #delete $self->{slots}->{msg};
}

sub printf {
  my $self = shift;
  my $text = shift;
  my @printf = $text =~ m/printf\("(.*?)"\s*,\s*(.*)\)/i;
  my $result = $text;
  my @replacements;
  for my $key (split /\s*,\s*/, $printf[1]) {
    if (defined $self->{variables}->{$key}) {
      push @replacements, $self->{variables}->{$key};
    } elsif (defined $self->{slots}->{$key}) {
      push @replacements, $self->{slots}->{$key};
    } else {
      print STDERR "$key not found\n";
      push @replacements,  '';
    }
  }
  eval {
      $result = sprintf($printf[0], @replacements);
  };
  return($result);
}

sub get_nagios_severity {
  my $self = shift;
  return $self->get_severity_mapping($self->{slots}->{severity});
}


package Nagios::CheckLogfiles;

use strict;
use IO::File;
use File::Basename;
use File::Spec;
use Cwd;
use Data::Dumper;
#use Net::Domain qw(hostname hostdomain hostfqdn);
use Socket;
use POSIX qw(strftime);
use IPC::Open2;


use constant GZIP => '/usr/bin/gzip';
my $ERROR_OK = 0;
my $ERROR_WARNING = 1;
my $ERROR_CRITICAL = 2;
my $ERROR_UNKNOWN = 3;

our $ExitCode = $ERROR_OK;
our $ExitMsg = "OK";
my(%ERRORS, $TIMEOUT);
%ERRORS = ( OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 );
$TIMEOUT = 60;

$| = 1;

eval "require Win32;";
#eval "require Net::Domain qw(hostname hostdomain hostfqdn);";
eval "require Net::Domain;";

sub new {
  my $class = shift;
  my $params = shift;
  my $self = bless {} , $class;
  return $self->init($params);
}

#
#  Read a hash with parameters
#
sub init {
  my $self = shift;
  my $params = shift;
  my($sec, $min, $hour, $mday, $mon, $year) = (localtime)[0, 1, 2, 3, 4, 5];
  $year += 1900; $mon += 1;
  $self->{tracefile} = $self->system_tempdir().'/check_logfiles.trace';
  $self->{trace} = -e $self->{tracefile} ? 1 : 0;
  $self->{seekfilesdir} = $params->{seekfilesdir} || '/var/tmp/check_logfiles';
  $self->{protocolsdir} = $params->{protocolsdir} || '/tmp';
  $self->{scriptpath} = $params->{scriptpath} || '/bin:/sbin:/usr/bin:/usr/sbin';
  $self->{protocolretention} = ($params->{protocolretention} || 7) * 24 * 3600;
  $self->{macros} = $params->{macros};
  $self->{timeout} = $params->{timeout};
  $self->{pidfile} = $params->{pidfile} || '/var/run/check_logfiles.pid';
  $self->{perfdata} = "";
  $self->{searches} = [];
  $self->{selectedsearches} = $params->{selectedsearches} || [];
  $self->{dynamictag} = $params->{dynamictag} || "";
  $self->{report} = $params->{report} || "short";
  $self->{cmdlinemacros} = $params->{cmdlinemacros} || {};
  $self->{reset} = $params->{reset} || 0;
  $self->default_options({ prescript => 1, smartprescript => 0,
      supersmartprescript => 0, postscript => 1, smartpostscript => 0,
      supersmartpostscript => 0 });
  if ($self->{report} !~ /^(long|short|html)$/) {
    $ExitCode = $ERROR_UNKNOWN;
    $ExitMsg = sprintf "UNKNOWN - output must be short, long or html";
    return undef;
  }
  if ($params->{cfgfile}) {
    if (ref($params->{cfgfile}) eq "ARRAY") {
      # multiple cfgfiles found in a config dir
      my @tmp_searches = ();
      $self->{cfgbase} = $params->{cfgbase} || "check_logfiles";
      foreach my $cfgfile (@{$params->{cfgfile}}) {
        $self->{cfgfile} = $cfgfile;
        if (! $self->init_from_file()) {
          return undef;
        }
        push(@tmp_searches, @{$self->{searches}});
        $self->{searches} = [];
      }
      my %seen = ();
      # newer searches replace searches with the same tag
      @tmp_searches = reverse map {
        if (! exists $seen{$_->{tag}}) {
          $seen{$_->{tag}}++;
          $_;
        } else {
          ();
        }
      } reverse @tmp_searches;
      $self->{searches} = \@tmp_searches;
      my $uniqueseekfile = undef;
      my $uniqueprotocolfile = undef;
      foreach (@{$self->{searches}}) {
        $_->{cfgbase} = "check_logfiles";
        next if $_->{tag} eq "prescript";
        next if $_->{tag} eq "postscript";
        $_->construct_seekfile();
      }
      #$self->{cfgbase} = (split /\./, basename($params->{cfgfile}->[0]))[0];
      $self->{cfgbase} = "check_logfiles";
    } else {
      $self->{cfgfile} = $params->{cfgfile};
      $self->{cfgbase} = (split /\./, basename($self->{cfgfile}))[0];
      if (! $self->init_from_file()) {
        return undef;
      }
    }
    # if there is a dynamictag parameter then replace template names with
    # template_dynamictagtag
    if (scalar(@{$self->{selectedsearches}})) {
      @{$self->{searches}} = map {
        my $srch = $_;
        if (grep {/^$srch->{tag}$/} @{$self->{selectedsearches}}) {
          $srch;
        } elsif (grep {/^$srch->{tag}$/} map { $_.'_'.$self->{dynamictag} } @{$self->{selectedsearches}}) {
          $srch;
        } elsif ($srch->{tag} eq "prescript") {
          $srch;
        } elsif ($srch->{tag} eq "postscript") {
          $srch;
        } else {
      	  $self->trace("skipping non-selected search %s", $srch->{tag});
          ();
        }
      } @{$self->{searches}};
    }
  } else {
    $self->{cfgbase} = $params->{cfgbase} || "check_logfiles";
    $self->init_macros;
    foreach (@{$params->{searches}}) {
      $_->{seekfilesdir} = $self->{seekfilesdir};
      $_->{scriptpath} = $self->{scriptpath};
      %{$_->{macros}} = %{$self->{macros}};
      $_->{tracefile} = $self->{tracefile};
      $_->{cfgbase} = $self->{cfgbase};
      $_->{report} = $self->{report};
      if (my $search = Nagios::CheckLogfiles::Search->new($_)) {
        push(@{$self->{searches}}, $search);
      } else {
        $ExitCode = $ERROR_UNKNOWN;
        $ExitMsg = sprintf "cannot create %s search %s",
            $_->{type}, $_->{tag};
        return undef;
      }
    }
  }
  if (defined(&Win32::GetShortPathName) && ($^O =~ /Win/)) {
    # if this is true windows (not cygwin) and if the path exists
    # then transform it to a short form. undef if path does not exist.
    if (my $tmpshortpath = &Win32::GetShortPathName($self->{protocolsdir})) {
      $self->{protocolsdir} = $tmpshortpath;
    }
  }
  $self->{protocolfile} =
      sprintf "%s/%s.protocol-%04d-%02d-%02d-%02d-%02d-%02d",
      $self->{protocolsdir}, $self->{cfgbase},
      $year, $mon, $mday, $hour, $min, $sec;
  $self->{protocololdfiles} = sprintf "%s/%s.protocol-*-*-*-*-*-*",
      $self->{protocolsdir}, $self->{cfgbase};
  $self->{protocolfh} = new IO::File;
  $self->{protocolwritten} = 0;
  $self->{allerrors} = { OK => 0, WARNING => 0, CRITICAL => 0, UNKNOWN => 0 };
  # if parameters update
  if (@{$self->{searches}}) {
    $self->{exitcode} = $ExitCode;
    $self->{exitmessage} = $ExitMsg;
    return $self;
  } else {
    $ExitCode = $ERROR_UNKNOWN;
    $ExitMsg = sprintf "UNKNOWN - configuration incomplete";
    return undef;
  }
}

sub init_from_file {
  my $self = shift;
  my $fullcfgfile;
  #
  #  variables from the config file.
  #
  our($seekfilesdir, $protocolsdir, $scriptpath, $protocolretention,
      $prescript, $prescriptparams ,$prescriptstdin, $prescriptdelay,
      $postscript, $postscriptparams, $postscriptstdin, $postscriptdelay,
      @searches, @logs, $tracefile, $options, $report, $timeout, $pidfile);
  our $MACROS = {};
  if (-f $self->{cfgfile}) {
    $fullcfgfile = $self->{cfgfile};
  } elsif (-f $self->{cfgfile}.'.cfg') {
    $fullcfgfile = $self->{cfgfile}.'.cfg';
  } elsif (-f $ENV{HOME}.'/'.$self->{cfgfile}) {
    $fullcfgfile = $ENV{HOME}.'/'.$self->{cfgfile};
  } elsif (-f $ENV{HOME}.'/'.$self->{cfgfile}.'.cfg') {
    $fullcfgfile = $ENV{HOME}.'/'.$self->{cfgfile}.'.cfg';
  } else {
    $ExitCode = $ERROR_UNKNOWN;
    $ExitMsg = sprintf "UNKNOWN - can not load configuration file %s",
        $self->{cfgfile};
    return undef;
  }
  $fullcfgfile = File::Spec->rel2abs($fullcfgfile)
      unless File::Spec->file_name_is_absolute($fullcfgfile);
  eval {
    require $fullcfgfile;
  };
  if ($@) {
    $ExitCode = $ERROR_UNKNOWN;
    $ExitMsg = sprintf "UNKNOWN - syntax error %s", (split(/\n/, $@))[0];
    return undef;
  }
  $self->{tracefile} = $tracefile if $tracefile;
  $self->{trace} = -e $self->{tracefile} ? 1 : 0;
  $self->{cfgbase} = (split /\./, basename($self->{cfgfile}))[0];
  $self->{seekfilesdir} = $seekfilesdir if $seekfilesdir;
  $self->{protocolsdir} = $protocolsdir if $protocolsdir;
  $self->{scriptpath} = $scriptpath if $scriptpath;
  $self->{protocolretention} = ($protocolretention * 24 * 3600) if $protocolretention;
  $self->{prescript} = $prescript if $prescript;
  $self->{prescriptparams} = $prescriptparams if $prescriptparams;
  $self->{prescriptstdin} = $prescriptstdin if $prescriptstdin;
  $self->{prescriptdelay} = $prescriptdelay if $prescriptdelay;
  $self->{postscript} = $postscript if $postscript;
  $self->{postscriptparams} = $postscriptparams if $postscriptparams;
  $self->{postscriptstdin} = $postscriptstdin if $postscriptstdin;
  $self->{postscriptdelay} = $postscriptdelay if $postscriptdelay;
  $self->{macros} = $MACROS if $MACROS;
  $self->{report} = $report if $report;
  $self->{timeout} = $timeout if $timeout;
  $self->{pidfile} = $pidfile if $pidfile;
  $self->{privatestate} = {};
  $self->init_macros;
  $self->refresh_options($options);
  if (@logs) {
    #
    # Since version 1.4 the what/where-array is called @searches.
    # To stay compatible, @logs is still recognized.
    #
    @searches = @logs;
  }
  if ($self->{options}->{prescript}) {
    $_->{scriptpath} = $self->{scriptpath};
    %{$_->{macros}} = %{$self->{macros}};
    $_->{tracefile} = $self->{tracefile};
    $_->{cfgbase} = $self->{cfgbase};
    $_->{script} = $self->{prescript};
    $_->{scriptparams} = $self->{prescriptparams};
    $_->{scriptstdin} = $self->{prescriptstdin};
    $_->{scriptdelay} = $self->{prescriptdelay};
    $_->{options} = sprintf "%s%sscript",
        $self->{options}->{supersmartprescript} ? "super" : "",
        $self->{options}->{smartprescript} ? "smart" : "";
    $_->{privatestate} = $self->{privatestate};
    my $search = Nagios::CheckLogfiles::Search::Prescript->new($_);
    push(@{$self->{searches}}, $search);
  }
  foreach (@searches) {
    $_->{seekfilesdir} = $self->{seekfilesdir};
    $_->{scriptpath} = $self->{scriptpath};
    %{$_->{macros}} = %{$self->{macros}};
    $_->{tracefile} = $self->{tracefile};
    $_->{cfgbase} = $self->{cfgbase};
    if ((exists $_->{template}) && ! $self->{dynamictag}) {
      # skip templates if they cannot be tagged
      next;
    }
    $_->{dynamictag} = $self->{dynamictag};
    $_->{report} = $self->{report};
    if (my $search = Nagios::CheckLogfiles::Search->new($_)) {
      push(@{$self->{searches}}, $search);
      $_->{privatestate}->{$search->{tag}} = $search->{privatestate};
    } else {
      $ExitCode = $ERROR_UNKNOWN;
      $ExitMsg = sprintf "cannot create %s search %s",
          $_->{type}, $_->{tag};
      return undef;
    }
  }
  if ($self->{options}->{postscript}) {
    $_->{scriptpath} = $self->{scriptpath};
    %{$_->{macros}} = %{$self->{macros}};
    $_->{tracefile} = $self->{tracefile};
    $_->{cfgbase} = $self->{cfgbase};
    $_->{script} = $self->{postscript};
    $_->{scriptparams} = $self->{postscriptparams};
    $_->{scriptstdin} = $self->{postscriptstdin};
    $_->{scriptdelay} = $self->{postscriptdelay};
    $_->{options} = sprintf "%s%sscript",
        $self->{options}->{supersmartpostscript} ? "super" : "",
        $self->{options}->{smartpostscript} ? "smart" : "";
    $_->{privatestate} = $self->{privatestate};
    my $search = Nagios::CheckLogfiles::Search::Postscript->new($_);
    push(@{$self->{searches}}, $search);
  }
  return $self;
}

sub run {
  my $self = shift;
  if ($self->{reset}) {
    foreach my $search (@{$self->{searches}}) {
      if ($search->{tag} ne "prescript" && $search->{tag} ne "postscript") {
        $search->loadstate();
        foreach (keys %{$search->{laststate}}) {
          $search->{newstate}->{$_} = $search->{laststate}->{$_};
        }
        $search->addevent(0, "reset");
        $search->{newstate}->{logoffset} = 0;
        $search->savestate();
      }
    }
    return $self;
  }
  foreach my $search (@{$self->{searches}}) {
    if (1) { # there will be a timesrunningout variable
      if ($search->{tag} eq "postscript") {
        $search->{macros}->{CL_SERVICESTATEID} = $self->{exitcode};
        $search->{macros}->{CL_SERVICEOUTPUT} = $self->{exitmessage};
        $search->{macros}->{CL_SERVICEPERFDATA} = $self->{perfdata};
        $search->{macros}->{CL_PROTOCOLFILE} = $self->{protocolfile};
        if ($search->{options}->{supersmartscript}) {
          #
          #  Throw away evrything found so far. Supersmart postscripts
          #  have the last word.
          #
          $self->reset_result();
        }
      }
      $search->run();
      if (($search->{tag} eq "prescript") &&
          ($search->{options}->{supersmartscript}) &&
          ($search->{exitcode} > 0)) {
        #
        #  Prepare for a premature end. A failed supersmart prescript
        #  will abort the whole script.
        #
        $self->reset_result();
        $self->trace("failed supersmart prescript. aborting...");
      }
      $_->{privatestate}->{$search->{tag}} = $search->{privatestate};
      if ($search->{options}->{protocol}) {
        if (scalar(@{$search->{matchlines}->{CRITICAL}}) ||
            scalar(@{$search->{matchlines}->{WARNING}}) ||
            scalar(@{$search->{matchlines}->{UNKNOWN}})) {
          if ($self->{protocolfh}->open($self->{protocolfile}, "a")) {
            foreach (qw(CRITICAL WARNING UNKNOWN)) {
              if (@{$search->{matchlines}->{$_}}) {
                $self->{protocolfh}->print(sprintf "%s Errors in %s (tag %s)\n",
                    $_, $search->{logbasename}, $search->{tag});
                foreach (@{$search->{matchlines}->{$_}}) {
                  $self->{protocolfh}->printf("%s\n", $_);
                }
              }
            }
            $self->{protocolfh}->close();
            $self->{protocolwritten} = 1;
          }
        }
      }
      if ($search->{options}->{count}) {
        foreach (qw(OK WARNING CRITICAL UNKNOWN)) {
          $self->{allerrors}->{$_} += scalar(@{$search->{matchlines}->{$_}});
          if ($search->{lastmsg}->{$_}) {
            $self->{lastmsg}->{$_} = $search->{lastmsg}->{$_};
          }
        }
      }
      $self->formulate_result();
      if (($search->{tag} eq "prescript") &&
          ($search->{options}->{supersmartscript}) &&
          ($search->{exitcode} > 0)) {
        #
        #  Failed supersmart prescript. I'm out...
        #
        last;
      } elsif (($search->{tag} eq "postscript") &&
          ($search->{options}->{supersmartscript})) {
        my $codestr = {reverse %ERRORS}->{$search->{exitcode}};
        ($self->{exitmessage}, $self->{perfdata}) =
            split(/\|/, $search->{lastmsg}->{$codestr}, 2);
        $self->{exitcode} = $search->{exitcode};
      }
    }
  }
  $self->cleanup_protocols();
  return $self;
}

sub formulate_result {
  my $self = shift;
  #
  #  create the summary from all information collected so far
  #
  $self->{hint} = sprintf "(%s", join(", ", grep { $_ }
    ($self->{allerrors}->{CRITICAL} ?
        sprintf "%d errors", $self->{allerrors}->{CRITICAL} : undef,
    $self->{allerrors}->{WARNING} ?
        sprintf "%d warnings", $self->{allerrors}->{WARNING} : undef,
    $self->{allerrors}->{UNKNOWN} ?
        sprintf "%d unknown", $self->{allerrors}->{UNKNOWN} : undef));
  if ($self->{protocolwritten}) {
    $self->{hint} .= sprintf " in %s)", basename($self->{protocolfile});
  } else {
    $self->{hint} .= ")";
  }
  foreach my $level qw(CRITICAL WARNING UNKNOWN OK) {
    $self->{exitcode} = $ERRORS{$level};
    if (($level ne "OK") && ($self->{allerrors}->{$level})) {
      $self->{exitmessage} = sprintf "%s - %s - %s %s", $level, $self->{hint},
          $self->{lastmsg}->{$level},
          ($self->{allerrors}->{$level} == 1 ? "" : "...");
      last;
    } else {
      $self->{exitmessage} = sprintf "OK - no errors or warnings";
    }
  }
  $self->{perfdata} = join (" ",
      map { $_->formulate_perfdata(); if ($_->{perfdata}) {$_->{perfdata}} else {()} }
      @{$self->{searches}});
  if ($self->{report} ne "short") {
    $self->formulate_long_result();
  }
}

sub formulate_long_result {
  my $self = shift;
  my $maxlength = 4 * 1024;
  $self->{long_exitmessage} = "";
  my $prefix = ($self->{report} eq "html") ?
      "<table style=\"border-collapse: collapse;\">" : "";
  my $suffix = ($self->{report} eq "html") ?
      "</table>" : "";
  my $messagelen = length($prefix) + length($suffix) +
      length($self->{exitmessage});
  my $line = "";

  foreach my $search (@{$self->{searches}}) {
    if (scalar(@{$search->{matchlines}->{CRITICAL}}) ||
        scalar(@{$search->{matchlines}->{WARNING}}) ||
        scalar(@{$search->{matchlines}->{UNKNOWN}})) {
      if ($self->{report} eq "html") {
        $line =
            sprintf "<tr valign=\"top\"><td class=\"service%s\">tag %s</td></tr>",
                ((scalar(@{$search->{matchlines}->{CRITICAL}}) && "CRITICAL") ||
                 (scalar(@{$search->{matchlines}->{WARNING}}) && "WARNING") ||
                 (scalar(@{$search->{matchlines}->{UNKNOWN}}) && "UNKNOWN")),
                $search->{tag};
      } else {
        $line =
            sprintf "tag %s %s\n",
                $search->{tag},
                ((scalar(@{$search->{matchlines}->{CRITICAL}}) && "CRITICAL") ||
                 (scalar(@{$search->{matchlines}->{WARNING}}) && "WARNING") ||
                 (scalar(@{$search->{matchlines}->{UNKNOWN}}) && "UNKNOWN"));
      }
      if ($messagelen + length($line) < $maxlength) {
        $self->{long_exitmessage} .= $line;
        $messagelen += length($line);
      } else {
        last;
      }
      foreach my $level qw(CRITICAL WARNING UNKNOWN OK) {
        foreach my $message (@{$search->{matchlines}->{$level}}) {
          if ($self->{report} eq "html") {
            $message =~ s/</&lt;/g;
            $message =~ s/>/&gt;/g;
            $line =
                sprintf "<tr valign=\"top\"><td nowrap width=\"100%%\" class=\"service%s\" style=\"border: 1px solid black;\">%s</td></tr>",
                $level, $message;
          } else {
            $line = sprintf "%s\n", $message;
          }
          if ($messagelen + length($line) < $maxlength) {
            $self->{long_exitmessage} .= $line;
            $messagelen += length($line);
          } else {
            last;
          }
        }
      }
    }
  }
  if ($self->{long_exitmessage}) {
    $self->{long_exitmessage} = sprintf "%s%s%s\n",
        $prefix, $self->{long_exitmessage}, $suffix;
  }
}

sub reset_result {
  my $self = shift;
  $self->{allerrors} = { OK => 0, WARNING => 0, CRITICAL => 0, UNKNOWN => 0 };
}

sub reset {
  my $self = shift;
  $self->{allerrors} = { OK => 0, WARNING => 0, CRITICAL => 0, UNKNOWN => 0 };
  foreach my $level qw(OK CRITICAL WARNING UNKNOWN) {
    $self->{lastmsg}->{$level} = "";
  }
  foreach my $search (@{$self->{searches}}) {
    $search->reset();
  }
}

sub cleanup_protocols {
  my $self = shift;
  #
  #  cleanup old protocol files
  #
  #
  if ($self->{protocololdfiles} =~ /[^\\][ ]/) {
    # because Core::glob splits the argument on whitespace
    $self->{protocololdfiles} =~ s/( )/\\$1/g;
  }
  foreach my $oldprotocolfile (glob "$self->{protocololdfiles}") {
    if ((stat $oldprotocolfile)[9] < (time - $self->{protocolretention})) {
      $self->trace("deleting old protocol %s", $oldprotocolfile);
      unlink $oldprotocolfile;
    }
  }
}

sub init_macros {
  my $self = shift;
  my($sec, $min, $hour, $mday, $mon, $year) = (localtime)[0, 1, 2, 3, 4, 5];
  my $cw = $^O =~ /MSWin/ ? 0 :
      strftime("%V", $sec, $min, $hour, $mday, $mon, $year, -1, -1, -1);
  $year += 1900; $mon += 1;
  #
  #  Set default values for the built-in macros.
  #
  my $DEFAULTMACROS = {
      CL_SERVICEDESC => $self->{cfgbase},
      CL_DATE_YYYY => sprintf("%04d", $year),
      CL_DATE_YY => substr($year,2,2),
      CL_DATE_MM => sprintf("%02d", $mon),
      CL_DATE_DD => sprintf("%02d", $mday),
      CL_DATE_HH => sprintf("%02d", $hour),
      CL_DATE_MI => sprintf("%02d", $min),
      CL_DATE_SS => sprintf("%02d", $sec),
      CL_DATE_TIMESTAMP => sprintf("%10d", time),
      CL_DATE_CW => sprintf("%02d", $cw),
      CL_NSCA_SERVICEDESC => $self->{cfgbase},
      CL_NSCA_HOST_ADDRESS => "127.0.0.1",
      CL_NSCA_PORT => 5667,
      CL_NSCA_TO_SEC => 10,
      CL_NSCA_CONFIG_FILE => "/usr/local/nagios/etc/send_nsca.cfg",
  };
  if (defined(&Win32::LoginName)) {
    $DEFAULTMACROS->{CL_USERNAME} = &Win32::LoginName();
    $DEFAULTMACROS->{CL_HAS_WIN32} = 1;
  } else {
    $DEFAULTMACROS->{CL_USERNAME} = scalar getpwuid $>;
    $DEFAULTMACROS->{CL_HAS_WIN32} = 0;
  }
  if (defined(&Net::Domain::hostname)) {
    $DEFAULTMACROS->{CL_HOSTNAME} = &Net::Domain::hostname();
    $DEFAULTMACROS->{CL_DOMAIN} = &Net::Domain::hostdomain();
    $DEFAULTMACROS->{CL_FQDN} = &Net::Domain::hostfqdn();
    $DEFAULTMACROS->{CL_HAS_NET_DOMAIN} = 1;
  } else {
    $DEFAULTMACROS->{CL_HOSTNAME} = POSIX::uname();
    $DEFAULTMACROS->{CL_DOMAIN} = "localdomain";
    $DEFAULTMACROS->{CL_FQDN} = POSIX::uname().'.'.'localdomain';
    $DEFAULTMACROS->{CL_HAS_NET_DOMAIN} = 0;
  }
#printf STDERR "%s\n", Data::Dumper::Dumper($DEFAULTMACROS);
  $DEFAULTMACROS->{CL_IPADDRESS} =
      scalar gethostbyname($DEFAULTMACROS->{CL_HOSTNAME}) ?
      inet_ntoa(scalar gethostbyname($DEFAULTMACROS->{CL_HOSTNAME})) :
      '127.0.0.1';
  #
  #  Add self-defined macros to the defaultmacros structure or overwrite
  #  already defined macros.
  #
  if ($self->{macros}) {
    foreach (keys %{$self->{macros}}) {
      $DEFAULTMACROS->{$_} = $self->{macros}->{$_};
    }
  }
  #
  #  Add self-defined macros from the command line
  #  --macro CL_KAAS="so a kaas" --macro CL_SCHMARRN="so a schmarrn"
  #
  if ($self->{cmdlinemacros}) {
    foreach (keys %{$self->{cmdlinemacros}}) {
      $DEFAULTMACROS->{$_} = $self->{cmdlinemacros}->{$_};
    }
  }
  #
  #  Escape the most commonly used special characters so they will no longer
  #  be treated like special characters in a pattern.
  #
  $self->{macros} = $DEFAULTMACROS;
  return $self;
}

#
#  Resolve macros in a string.
#  If a second parameter is given, then this string is meant as a regular expression.
#  Escape special characters accordingly.
#
sub resolve_macros {
  my $self = shift;
  my $pstring = shift;
  while ($$pstring =~ /.*\$(\w+)\$.*/g) {
    my $maybemacro = $1;
    if (exists $self->{macros}->{$maybemacro}) {
      my $macro = $self->{macros}->{$maybemacro};
      $$pstring =~ s/\$$maybemacro\$/$macro/;
    }
  }
}

sub resolve_macros_in_pattern {
  my $self = shift;
  my $pstring = shift;
  while ($$pstring =~ /.*\$(\w+)\$.*/g) {
    my $maybemacro = $1;
    if (exists $self->{macros}->{$maybemacro}) {
      my $macro = $self->{macros}->{$maybemacro};
   	  #
      #  Escape the most commonly used special characters so they will no longer
      #  be treated like special characters in a pattern.
      #
      $macro =~ s|/|\\/|g;
      $macro =~ s|\-|\\-|g;
      $macro =~ s|\.|\\.|g;
      $$pstring =~ s/\$$maybemacro\$/$macro/;
    }
  }
}

sub default_options {
  my $self = shift;
  my $defaults = shift;
  while (my($key, $value) = each %{$defaults}) {
    $self->{options}->{$key} = $value;
  }
}

sub refresh_options {
  my $self = shift;
  my $options = shift;
  if ($options) {
    foreach my $option (split /,/, $options) {
      my $optarg = undef;
      $option =~ s/^\s+//;
      $option =~ s/\s+$//;
      if ($option =~ /(.*)=(.*)/) {
      	$option = $1;
      	$optarg = $2;
        $optarg =~ s/^"//;
        $optarg =~ s/"$//;
        $optarg =~ s/^'//;
        $optarg =~ s/'$//;
      }
      foreach my $defoption (keys %{$self->{options}}) {
        if ($option eq $defoption) {
          if ($optarg) {
          	# example: sticky=3600,syslogclient="winhost1.dom"
          	$self->{options}->{$defoption} = $optarg;
          } else {
            $self->{options}->{$defoption} = 1;
          }
        } elsif ($option eq 'no'.$defoption) {
          $self->{options}->{$defoption} = 0;
        }
      }
    }
  }
  # reset [smart][pre|post]script options if no script should be called
  foreach my $option (qw(script prescript postscript)) {
    if (exists $self->{options}->{'supersmart'.$option}) {
      $self->{options}->{'smart'.$option} = 1
          if $self->{options}->{'supersmart'.$option};
    }
    if (exists $self->{options}->{'smart'.$option}) {
      $self->{options}->{$option} = 1
          if $self->{options}->{'smart'.$option};
    }
    if (exists $self->{options}->{$option}) {
      if (($self->{options}->{$option}) && ! exists $self->{$option}) {
        $self->{options}->{$option} = 0;
        $self->{options}->{'smart'.$option} = 0;
        $self->{options}->{'supersmart'.$option} = 0;
      }
    }
  }
  if ($self->{options}->{sticky}) {
    if ($self->{options}->{sticky} > 1) {
      $self->{maxstickytime} = $self->{options}->{sticky};
      $self->{options}->{sticky} = 1;
    } else {
      $self->{maxstickytime} = 3600 * 24 * 365 * 10;
    }
  }
  if ($self->{options}->{syslogclient}) {
#    $self->{prefilter} = $self->{options}->{syslogclient};
  }
}

sub trace {
  my $self = shift;
  my $format = shift;
  if ($self->{verbose}) {
    printf("%s: ", scalar localtime);
    printf($format, @_);
  }
  if ($self->{trace}) {
    my $logfh = new IO::File;
    $logfh->autoflush(1);
    if ($logfh->open($self->{tracefile}, "a")) {
      $logfh->printf("%s: ", scalar localtime);
      $logfh->printf($format, @_);
      $logfh->printf("\n");
      $logfh->close();
    }
  }
}

sub action {
  my $self = shift;
  my $script = shift;
  my $scriptparams = shift;
  my $scriptstdin = shift;
  my $scriptdelay = shift;
  my $smart = shift;
  my $privatestate = shift;
  my $success = 0;
  my $rc = 0;
  my $exitvalue;
  my $signalnum;
  my $dumpedcore;
  my $output;
  my $pid = 0;
  my $wait = 0;
  my $strerror = (qw(OK WARNING CRITICAL UNKNOWN))
      [$self->{macros}->{CL_SERVICESTATEID}];
  my $cmd;
  my @stdinformat = ();
  foreach my $macro (keys %{$self->{macros}}) {
    my $envmacro = $macro;
    if ($envmacro =~ /^CL_/) {
      $envmacro =~ s/^CL_/CHECK_LOGFILES_/;
    } else {
      $envmacro = "CHECK_LOGFILES_".$macro;
    }
    $ENV{$envmacro} = $self->{macros}->{$macro};
  }
  $ENV{CHECK_LOGFILES_SERVICESTATE} = qw(OK WARNING CRITICAL UNKNOWN)
      [$ENV{CHECK_LOGFILES_SERVICESTATEID}];
  if (ref $script eq "CODE") {
    $self->trace("script is of type %s", ref $script);
    if (ref($scriptparams) eq "ARRAY") {
      foreach (@{$scriptparams}) {
        $self->resolve_macros(\$_) if $_;
      }
    }
    my $stdoutvar;
    *SAVEOUT = *STDOUT;
    eval {
      our $CHECK_LOGFILES_PRIVATESTATE = $privatestate;
      open OUT ,'>',\$stdoutvar;
      *STDOUT = *OUT;
      $exitvalue = &{$script}($scriptparams, $scriptstdin);
    };
    *STDOUT = *SAVEOUT;
    if ($@) {
      $output = $@;
      $success = 0;
      $rc = -1;
      $self->trace("script said: %s", $output);
    } else {
      #$output = $stdoutvar || "";
      $output = defined $stdoutvar ?  $stdoutvar :  "";
      chomp $output;
      $self->trace("script said: %s", $output);
      if ($smart) {
        if (($exitvalue =~ /^\d/) && ($exitvalue >= 0 && $exitvalue <= 3)) {
          $success = 1;
          $rc = $exitvalue;
          $self->trace("script %s exits with code %d", $script, $rc);
        } else {
          $success = 1;
          $rc = -4;
          $self->trace("script %s failed for unknown reasons", $script);
        }
      } else {
        $success = 1;
        $rc = $exitvalue;
        $output = $self->{macros}->{CL_SERVICEOUTPUT};
      }
    }
  } else {
    my $pathsep = ($^O =~ /MSWin/) ? ';' : ':';
    foreach my $dir (split(/$pathsep/, $self->{scriptpath})) {
      if ( -x $dir.'/'.$script ) {
        $self->trace(sprintf "found script in %s/%s", $dir, $script);
        $cmd = sprintf "%s/%s", $dir, $script;
        if ($^O =~ /MSWin/) {
          $cmd =~ s/\//\\/g;
          if ($cmd =~ /\s/) {
            if (defined(&Win32::GetShortPathName)) {
              $cmd = &Win32::GetShortPathName($cmd);
            } else {
              $cmd = sprintf "\"%s\"", $cmd;
            }
          }
        } else {
          # need to escape blanks
          if ($cmd =~ /\s/) {
            $cmd =~ s/([ ])/\\$1/g;
          }
        }
        last;
      }
    }
    if ($cmd) {
      if (defined $scriptparams) {
        $self->resolve_macros(\$scriptparams);
        $cmd = sprintf "%s %s", $cmd, $scriptparams;
      }
      $self->trace(sprintf "execute %s", $cmd);
      if (defined $scriptstdin) {
        my $pid = 0;
        my $wait = 0;
        my $maxlines = 100;
        if (! ref($scriptstdin eq "ARRAY")) {
        	$scriptstdin = [$scriptstdin];
        }
        foreach (@{$scriptstdin}) {
          $self->resolve_macros(\$_);
        }
        @stdinformat = @{$scriptstdin};
        #  if the format string was defined using single quotes, the escape
        #  characters must be expanded.
        $stdinformat[0] =~ s/\\t/\t/g;
        $stdinformat[0] =~ s/\\n/\n/g;
        $SIG{'PIPE'} = sub {};
        $SIG{'CHLD'} = sub {};
        my($chld_out, $chld_in);
        $pid = open2($chld_out, $chld_in, $cmd);
        $self->trace("stdin is <<EOF");
        $self->trace(@stdinformat);
        $self->trace("EOF");
        $chld_in->printf(@stdinformat);
        $chld_in->close();
        $output = $chld_out->getline() || "";
        while ($maxlines-- > 0) {
          # sucking the remaining output to avoid sigpipe
          $chld_out->getline() || last;
        }
        chomp $output;
        $chld_out->flush();
        $chld_out->close();
        $wait = waitpid $pid, 0;
        $exitvalue  = $? >> 8;
        $signalnum  = $? & 127;
        $dumpedcore = $? & 128;
        if (($signalnum == 13) && ($maxlines < 0)) {
          $signalnum = 0;
          # the script printed more than the allowed 100 lines of output.
          # closing the descriptor $chld_out caused a SIGPIPE which will
          # be accepted here.
        }
      } else {
        $output = (`$cmd`)[0] || "";
        $exitvalue  = $? >> 8;
        $signalnum  = $? & 127;
        $dumpedcore = $? & 128;
        chomp $output;
      }
      $self->trace("script said: %s", $output);
      if ($wait != $pid) {
        $success = 0;
        $rc = -5;
        $self->trace("wait %d != %d", $wait, $pid);
      } elsif ($signalnum) {
        $success = 0;
        $rc = -2;
        $self->trace("script %s received signal %d", $script, $signalnum);
        $self->trace("script %s exits with code %d", $script, $rc);
      } elsif ($dumpedcore) {
        $success = 0;
        $rc = -3;
        $self->trace("script %s failed with core dump", $script);
      } elsif ($smart) {
        if ($exitvalue >= 0 && $exitvalue <= 3) {
          $success = 1;
          $rc = $exitvalue;
          $self->trace("script %s exits with code %d", $script, $rc);
        } else {
          $success = 0;
          $rc = -4;
          $self->trace("script %s failed for unknown reasons", $script);
        }
      } else {
        $success = 1;
        $rc = $exitvalue;
        $output = $self->{macros}->{CL_SERVICEOUTPUT};
      }
    } else {
      $self->trace(sprintf "could not find %s", $script);
      $success = 0;
      $rc = -1;
    }
  }
  if ($scriptdelay) {
    $self->trace(sprintf "sleeping for %d seconds", $scriptdelay);
    sleep $scriptdelay;
  }
  map { /^CHECK_LOGFILES/ && delete $ENV{$_}; } keys %{$ENV};
  if($output) {
    # remove ticks in case the script was badly programmed
    # this is ugly and should be left to the scripts author
    $output =~ s/^"//;
    $output =~ s/"$//g;
  }
  return ($success, $rc, $output)
}


sub getfilefingerprint {
  my $self = shift;
  my $file = shift;
  if (-f $file) {
    if ($^O eq "MSWin32") {
      my $magic;
      if (ref $file) {
        my $pos = $file->tell();
        $file->seek(0, 0);
        $magic = $file->getline() || "this_was_an_empty_file";
        $file->seek(0, $pos);
      } else {
        my $fh = new IO::File;
        $fh->open($file, "r");
        $magic = $fh->getline() || "this_was_an_empty_file";
        $fh->close();
      }
      if ($self->{options}->{encoding}) {
        $magic =~ tr/\x80-\xFF//d;
        $magic =~ tr/\x00-\x1F//d;
      }
      $self->trace("magic: %s", $magic);
      #return(md5_base64($magic));
      return(unpack("H*", $magic));
      # use the creation time as unique identifier
      # haaaahaaaaaa win32 creation time is a good joke
      # google for "tunneling"
      return sprintf "0:%d", (stat $file)[10];
      #return "0:0";
    } else {
      return sprintf "%d:%d", (stat $file)[0], (stat $file)[1];
    }
  } else {
    return "0:0";
  }
}


sub getfilesize {
  my $self = shift;
  my $file = shift;
  return (-f $file) ? (stat $file)[7] : 0;
}

sub getfileisreadable {
  my $self = shift;
  my $file = shift;
  if ($^O =~ /MSWin/) {
    # -r is not reliable when working with cacls
    my $fh = new IO::File;
    if ($fh->open($file, "r")) {
      $fh->close();
      return 1;
    } else {
      return undef;
    }
  } elsif (-r $file) {
    return 1;
  } else {
    use filetest 'access';
    $self->trace("stat (%s) failed, try access instead", $file);
    if (-r $file) {
      return 1;
    } else { # i'm catholic. i believe in miracles.
      my $fh = new IO::File;
      if ($fh->open($file, "r")) {
        $fh->close();
        return 1;
      } else {
        return 0;
      }
    }
  }
}

sub old_getfileisreadable {
  my $self = shift;
  my $file = shift;
  my $fh = new IO::File;
  if ($^O =~ /MSWin/) {
    if ($fh->open($file, "r")) {
      $fh->close();
      return 1;
    } else {
      return undef;
    }
  } elsif (($^O eq "linux") || ($^O eq "cygwin")) {
    if (! -r $file) {
      use filetest 'access';
      $self->trace("stat (%s) failed, try access instead", $file);
      return -r $file;
    }
    return -r $file;
  } else {
    return -r $file;
  }
}

sub system_tempdir {
  my $self = shift;
  if ($^O =~ /MSWin/) {
    return $ENV{TEMP} if defined $ENV{TEMP};
    return $ENV{TMP} if defined $ENV{TMP};
    return File::Spec->catfile($ENV{windir}, 'Temp')
        if defined $ENV{windir};
    return 'C:\Temp';
  } else {
  	return "/tmp";
  }
}

sub run_as_daemon {
  my $self = shift;
  my $delay = shift;
  if ($^O =~ /MSWin/) {
    if ($ENV{PROMPT}) { # i was called from a shell
      # vielleicht irgendwas mit detach
      die "not yet implemented";
    } else {
      eval "require Win32::Daemon;";
      if (defined(&Win32::Daemon::StartService)) {
        import Win32::Daemon;
        my $svc_callback = sub {
          my( $event, $context ) = @_;
          #
          # entgegen der DRECKSDOKU enthaelt $event NICHT den Status
          #
          $event = Win32::Daemon::State();
          $context->{last_event} = $event;
          if ($event == SERVICE_RUNNING()) {
            # main loop
            $self->trace("Entering main loop");
            do {
              $self->run();
              $self->trace(sprintf "%s%s\n%s", $self->{exitmessage},
                  $self->{perfdata} ? "|".$self->{perfdata} : "",
                  $self->{long_exitmessage} ?
                      $self->{long_exitmessage}."\n" : "");
              $self->reset();
              foreach (1..$delay) {
                if (Win32::Daemon::State() == SERVICE_RUNNING()) {
                  sleep 1;
                } else {
                  last;
                }
              }
            } while(Win32::Daemon::State() == SERVICE_RUNNING());
            $self->trace("Leaving main loop");
          } elsif ($event == SERVICE_START_PENDING()) {
            # Initialization code
            $self->trace("Service initialized");
            $context->{last_state} = SERVICE_RUNNING();
            Win32::Daemon::State(SERVICE_RUNNING());
          } elsif ($event == SERVICE_PAUSE_PENDING()) {
            $self->trace("Service makes a break");
            $context->{last_state} = SERVICE_PAUSED();
            Win32::Daemon::State(SERVICE_PAUSED());
          } elsif ($event == SERVICE_CONTINUE_PENDING()) {
            $self->trace("Service continues");
            $context->{last_state} = SERVICE_RUNNING();
            Win32::Daemon::State(SERVICE_RUNNING());
          } elsif ($event == SERVICE_STOP_PENDING()) {
            $self->trace("Service stops");
            $context->{last_state} = SERVICE_STOPPED();
            $self->trace("Daemon exiting...");
            Win32::Daemon::State(SERVICE_STOPPED());
            Win32::Daemon::StopService();
          } else {
            # Take care of unhandled states by setting the State()
            # to whatever the last state was we set...
            $self->trace("Service got an unhandled call");
            Win32::Daemon::State( $context->{last_state} );
          }
          return();
        };
        Win32::Daemon::RegisterCallbacks($svc_callback);
        my %context = (
            count   =>  0,
            start_time => time(),
            keep_going => 0,
            make_a_break => 0,
        );
        # Start the service passing in a context and
        # indicating to callback using the "Running" event
        # every 2000 milliseconds (2 seconds).
        Win32::Daemon::StartService(\%context, 2000);
      } else {
        die "omeiomeiomei nix Win32::Daemon";
      }
    }
  } else {
    chdir '/';
    open STDIN, '/dev/null';
    open STDOUT, '/dev/null';
    exit if (fork());
    exit if (fork());
    sleep 1 until getppid() == 1;
    open STDERR, '>&STDOUT';
    my $keep_going = 1;
    # $self->{pidfile};
    $self->trace(sprintf "Daemon running with pid %d", $$);
    foreach my $signal (qw(HUP INT TERM QUIT)) {
      $SIG{$signal}  = sub {
        $self->trace("Caught SIG%s:  exiting gracefully", $signal);
        $keep_going = 0;
      };
    }
    $self->trace("Entering main loop");
    do {
      $self->run();
      $self->trace(sprintf "%s%s\n%s", $self->{exitmessage},
          $self->{perfdata} ? "|".$self->{perfdata} : "",
          $self->{long_exitmessage} ? $self->{long_exitmessage}."\n" : "");
      $self->reset();
      foreach (1..$delay) {
        if ($keep_going) {
          sleep 1;
        } else {
          last;
        }
      }
    } while($keep_going);
    $self->trace("Daemon exiting...");
  }
}

sub install_windows_service {
  my $self = shift;
  my $servicename = shift || 'check_logfiles';
  my $cfgfile = shift;
  my $username = shift;
  my $password = shift;
  if ($^O =~ /MSWin/) {
    eval "require Win32::Daemon;";
    if (defined(&Win32::Daemon::StartService)) {
      import Win32::Daemon;
      my $fullpath = Win32::GetFullPathName($0);
      my ($cwd, $base, $ext) = ( $fullpath =~ /^(.*\\)(.*)\.(.*)$/ ) [0..2] ;
      my $servicepath = ($ext eq 'exe') ?
          "\"$fullpath\"" : "\"$^X\"";
      my $serviceparameters = ($ext eq 'exe') ?
          "--daemon --config \"$cfgfile\"" :
          " \"$fullpath\" --daemon --config \"$cfgfile\"";
      my $service = {
        machine => '',
        name => $servicename,
        display => $servicename,
        path => $servicepath,
        parameters => $serviceparameters,
        user => ($username || ''),
        password => ($password || ''),
        description => 'This is the Nagios plugin check_logfiles',
      };
      if (Win32::Daemon::CreateService($service)) {
        $self->{exitmessage} = 'Successfully added service';
        $self->{exitcode} = 0;
      } else {
        $self->{exitmessage} = 'Failed to add service: '.
            Win32::FormatMessage(Win32::Daemon::GetLastError());
        $self->{exitcode} = 3;
      }
    } else {
      die "nix Win32::Daemon, nix Service, nix install";
    }
  } else {
    $self->{exitmessage} = 'You just installed a Windows service on a Unix machine. Good luck.';
    $self->{exitcode} = 0;
  }
}

sub deinstall_windows_service {
  my $self = shift;
  my $servicename = shift || 'check_logfiles';
  if ($^O =~ /MSWin/) {
    eval "require Win32::Daemon;";
    if (defined(&Win32::Daemon::StartService)) {
      import Win32::Daemon;
      if (Win32::Daemon::DeleteService('', $servicename)) {
        $self->{exitmessage} = 'Successfully deinstalled service';
        $self->{exitcode} = 0;
      } else {
        $self->{exitmessage} = 'Failed to deinstall service: '.
            Win32::FormatMessage(Win32::Daemon::GetLastError());
        $self->{exitcode} = 3;
      }
    }
  } else {
    $self->{exitmessage} = 'Congrats. You just deinstalled a Windows service on a Unix machine.';
    $self->{exitcode} = 0;
  }
}

package Nagios::CheckLogfiles::Search;

use strict;
use Exporter;
use File::Basename;
use POSIX qw(SSIZE_MAX);
#use Unicode::Normalize;
#use Encode;
use vars qw(@ISA);

use constant OK => 0;
use constant WARNING => 1;
use constant CRITICAL => 2;
use constant UNKNOWN => 3;

@ISA = qw(Nagios::CheckLogfiles);

sub new {
  my $self = bless {}, shift;
  my $params = shift;
  $self->{tag} = $params->{tag} || 'default';
  $self->{template} = $params->{template} if $params->{template};
  $self->{dynamictag} = $params->{dynamictag} if $params->{dynamictag};
  if (exists $self->{template} && exists $self->{dynamictag}) {
    $self->{tag} = $self->{template}.'_'.$self->{dynamictag};
  } else {
    $self->{tag} = $params->{tag} || 'default';
  }
  $self->{type} = $params->{type};
  $self->{logfile} = $params->{logfile};
  $self->{rotation} = $params->{rotation};
  $self->{script} = $params->{script};
  $self->{scriptparams} = $params->{scriptparams};
  $self->{scriptstdin} = $params->{scriptstdin};
  $self->{scriptdelay} = $params->{scriptdelay};
  $self->{cfgbase} = $params->{cfgbase} || "check_logfiles";
  $self->{seekfilesdir} = $params->{seekfilesdir} || $self->system_tempdir();
  $self->{archivedir} = $params->{archivedir};
  $self->{scriptpath} = $params->{scriptpath};
  $self->{macros} = $params->{macros};
  $self->{tracefile} = $params->{tracefile};
  $self->{prefilter} = $params->{prefilter};
  $self->{trace} = -e $self->{tracefile} ? 1 : 0;
  $self->{report} = $params->{report};
  if (exists $params->{tivolipatterns}) {
    my $tivoliparams = { };
    my $tivolipatterns = [];
    my $tivoliformatfiles = [];
    my $tivoliformatstrings = [];
    if (ref($params->{tivolipatterns}) ne 'ARRAY') {
      $tivolipatterns = [$params->{tivolipatterns}];
    } else {
      push(@{$tivolipatterns}, @{$params->{tivolipatterns}});
    }
    foreach my $pattern (@{$tivolipatterns}) {
      if (scalar(@{[split /\n/, $pattern]}) == 1) {
        push(@{$tivoliparams->{formatfile}}, $pattern);
      } else {
        #push(@{$tivoliparams->{formatstring}}, $pattern);
        # erstmal nur skalar moeglich
        $tivoliparams->{formatstring} = $pattern;
      }
    }
    if (exists $params->{tivolimapping}) {
      foreach (keys %{$params->{tivolimapping}}) {
        $tivoliparams->{severity_mappings}->{lc $_} = 0 if
            $params->{tivolimapping}->{$_} =~ /(?i)ok/;
        $tivoliparams->{severity_mappings}->{lc $_} = 1 if
            $params->{tivolimapping}->{$_} =~ /(?i)warning/;
        $tivoliparams->{severity_mappings}->{lc $_} = 2 if
            $params->{tivolimapping}->{$_} =~ /(?i)critical/;
        $tivoliparams->{severity_mappings}->{lc $_} = 3 if
            $params->{tivolimapping}->{$_} =~ /(?i)unknown/;
        $tivoliparams->{severity_mappings}->{lc $_} =
            $params->{tivolimapping}->{$_} if
            $params->{tivolimapping}->{$_} =~ /\d/;
      }
    }
    if ($self->{tivoli}->{object} = Nagios::Tivoli::Config::Logfile->new(
        $tivoliparams )) {
    } else {
      die "could not create tivoli object from $params->{tivolipatterns}";
    }
  }
  if (! $self->{type}) {
    if ($self->{rotation}) {
      $self->{type} = "rotating";
    } else {
      $self->{type} = "simple";
    }
  }
  $self->{privatestate} = {};
  my $class = sprintf "Nagios::CheckLogfiles::Search::%s",
      join "::", map {
          (uc substr($_, 0, 1)).substr($_, 1);
      } split(/::/, $self->{type});
  bless $self, $class;
  if (! $self->can("init")) {
  	#
  	#  Maybe $class was not defined in this file. Try to find
  	#  the external module.
  	#
    my $module = $class.".pm";
    $module =~ s/::/\//g;
  	foreach (@INC) {
  	  if (-f $_."/$module") {
  	    require $module;
  	    bless $self, $class;
  	    last;
  	  }
  	}
  }
  if ($self->can("init")) {
    $self->init($params);
  } else {
    $self = undef;
  }
  return $self;
}

#
#  Read a hash with parameters
#
sub init {
  my $self = shift;
  my $params = shift;
  $self->{laststate} = {};
  $self->{relevantfiles} = [];
  $self->{preliminaryfilter} = { SKIP => [], NEED => [] };
  $self->{matchlines} = { OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [] };
  $self->{lastmsg} = { OK => "", WARNING => "", CRITICAL => "", UNKNOWN => "" };
  $self->{patterns} = { OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [] };
  $self->{negpatterns} = { OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [] };
  $self->{negpatterncnt} = { OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [] };
  $self->{exceptions} = { OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [] };
  $self->{threshold} = { OK => 0, WARNING => 0, CRITICAL => 0, UNKNOWN => 0 };
  $self->{thresholdcnt} = { OK => 0, WARNING => 0, CRITICAL => 0, UNKNOWN => 0 };
  $self->{hasinversepat} = 0;
  $self->{likeavirgin} = 0;
  $self->{linesread} = 0;
  $self->{linenumber} = 0; # used for context
  $self->{perfdata} = "";
  $self->{max_readsize} = 1024 * 1024 * 128;
  # sysread can only read SSIZE_MAX bytes in one operation.
  # this is often (1024 * 1024 * 1024 * 2) - 1 = 2GB - 1
  # if we need to read from a non-seekable filehandle more than this
  # amount of data, then we have to perform multiple reads.
  # because the $bytes variable must hold the result of such a read and
  # its size is limited by available memory, it is divided by 16
  # so each read request does not overburden the sysread call and
  # does not inflate the process to more than 128MB
  #
  # options
  #
  $self->default_options({ script => 0, smartscript => 0, supersmartscript => 0,
      protocol => 1, count => 1, syslogserver => 0, logfilenocry => 1,
      perfdata => 1, case => 1, sticky => 0, syslogclient => 0,
      savethresholdcount => 1, encoding => 0, maxlength => 0,
      lookback => 0, context => 0,
      warningthreshold => 0, criticalthreshold => 0, unknownthreshold => 0 } );
  $self->refresh_options($params->{options});
  #
  #  Dynamic logfile names may contain macros.
  #
  if (exists $self->{template} && exists $self->{dynamictag}) {
    $self->{macros}->{CL_TAG} = $self->{dynamictag};
    $self->{macros}->{CL_TEMPLATE} = $self->{template};
  } else {
    $self->resolve_macros(\$self->{tag});
    $self->{macros}->{CL_TAG} = $self->{tag};
  }
  $self->resolve_macros(\$self->{logfile});
  $self->{macros}->{CL_LOGFILE} = $self->{logfile};
  $self->{logbasename} = basename($self->{logfile});
  $self->{archivedir} = exists $params->{archivedir} ? $params->{archivedir} :
      dirname($self->{logfile});
  $self->resolve_macros(\$self->{archivedir});
  #
  #  Preliminary filter
  #
  if ($self->{prefilter}) {
    my $pattern = $self->{prefilter};
    $self->resolve_macros_in_pattern(\$pattern);
    $pattern = '(?i)'.$pattern unless $self->{options}->{case};
    $self->addfilter(1, $pattern);
  }
  if ($self->{options}->{syslogclient}) {
    my $pattern = $self->{options}->{syslogclient};
    $self->resolve_macros_in_pattern(\$pattern);
    $pattern = '(?i)'.$pattern unless $self->{options}->{case};
    $self->addfilter(1, $pattern);
  }
  if ($self->{options}->{syslogserver}) {
    my $pattern = '($CL_HOSTNAME$|localhost)';
    $self->resolve_macros_in_pattern(\$pattern);
    $pattern = '(?i)'.$pattern unless $self->{options}->{case};
    $self->addfilter(1, $pattern);
  }
  #
  # the guy who begged me for the encoding option never wrote me a mail again.
  # this means for me, encoding works perfect. if it does not work for you
  # then it's not my problem.
  #
  if ($self->{options}->{encoding}) {
    #require Encode qw(encode decode);
    require Encode;
  }
  #
  #  Setup the structure describing what to search for.
  #
  foreach my $level qw(OK CRITICAL WARNING UNKNOWN) {
    #
    #  if a single pattern was given as a scalar, force it into an array
    #  and resolve macros.
    #
    if (exists $params->{(lc $level).'patterns'}) {
      if (ref($params->{(lc $level).'patterns'}) ne 'ARRAY') {
        $self->{patterns}->{$level} = [$params->{(lc $level).'patterns'}];
      } else {
        push(@{$self->{patterns}->{$level}}, @{$params->{(lc $level).'patterns'}});
      }
      foreach my $pattern (@{$self->{patterns}->{$level}}) {
        $self->resolve_macros_in_pattern(\$pattern);
      }

      if (exists $params->{(lc $level).'exceptions'}) {
        if (ref($params->{(lc $level).'exceptions'}) ne 'ARRAY') {
          $self->{exceptions}->{$level} = [$params->{(lc $level).'exceptions'}];
        } else {
          push(@{$self->{exceptions}->{$level}}, @{$params->{(lc $level).'exceptions'}});
        }
        foreach my $pattern (@{$self->{exceptions}->{$level}}) {
          $self->resolve_macros_in_pattern(\$pattern);
        }
      }
      #
      #  separate the pattern arrays. patterns beginning with a "!" will raise
      #  an error if they cannot be found.
      #  this type of pattern also needs a counter for the matches because after
      #  scanning the logfiles we must also check for a "not-found" condition.
      #
      @{$self->{negpatterns}->{$level}} = map {
        if (substr($_, 0, 1) eq "!") {
          push(@{$self->{negpatterncnt}->{$level}}, 0);
          substr($_, 1)
        } else { () }
      } @{$self->{patterns}->{$level}};
      if (scalar(@{$self->{negpatterns}->{$level}})) {
        $self->{hasinversepat} = 1;
        @{$self->{patterns}->{$level}} = map {
          if (substr($_, 0, 1) ne "!") { $_ } else { () }
        } @{$self->{patterns}->{$level}};
      }
      #
      #  prepend the patterns with (?i) if the case insensitivity option is set
      #
      if (! $self->{options}->{case}) {
      	foreach my $pattern (@{$self->{patterns}->{$level}}) {
      	  $pattern = '(?i)'.$pattern;
      	}
      	foreach my $pattern (@{$self->{negpatterns}->{$level}}) {
      	  $pattern = '(?i)'.$pattern;
      	}
      	foreach my $pattern (@{$self->{exceptions}->{$level}}) {
      	  $pattern = '(?i)'.$pattern;
      	}
      }
      #
      #  ignore the match unless a minimum of threshold occurrances were found
      #
      if ((! $self->{options}->{(lc $level).'threshold'}) &&
          ($params->{(lc $level).'threshold'})) {
        $self->{options}->{(lc $level).'threshold'} =
            $params->{(lc $level).'threshold'};
      }
      if ($self->{options}->{(lc $level).'threshold'}) {
        $self->{threshold}->{$level} = $self->{options}->{(lc $level).'threshold'} - 1;
      } else {
        $self->{threshold}->{$level} = 0;
      }
    }
  }
  foreach my $level qw(CRITICAL WARNING UNKNOWN) {
    foreach my $pattern (@{$self->{negpatterns}->{$level}}) {
      push(@{$self->{negpatterncnt}->{$level}}, 0);
    }
  }
  if (exists $self->{tivoli}->{object}) {
    $self->{patterns} = { OK => [], WARNING => [],
        CRITICAL => ['.*'], UNKNOWN => [] };
    $self->{tivoli}->{object}->set_format_mappings(
      hostname => $self->{macros}->{CL_HOSTNAME},
      fqhostname => $self->{macros}->{CL_FQDN},
      origin => $self->{macros}->{CL_IPADDRESS},
      FILENAME => (ref($self) eq 'Nagios::CheckLogfiles::Search::Eventlog') ?
          'EventLog' : $self->{macros}->{CL_LOGFILE},
          # oder SysLogD
      LABEL => $self->{macros}->{CL_HOSTNAME}, # NON-TME
    );
  }
  $self->construct_seekfile();
  $self->{NH_detection} = ($^O =~ /MSWin/) ? 0 : 1;
  return $self;
}

sub construct_seekfile {
  my $self = shift;
  # since 2.0 the complete path to the logfile is mapped to the seekfilename
  $self->{seekfilebase} = $self->{logfile};
  $self->{seekfilebase} =~ s/\//_/g;
  $self->{seekfilebase} =~ s/\\/_/g;
  $self->{seekfilebase} =~ s/:/_/g;
  $self->{seekfilebase} =~ s/\s/_/g;
  $self->{seekfile} = sprintf "%s/%s.%s.%s", $self->{seekfilesdir},
      $self->{cfgbase}, $self->{seekfilebase},
      $self->{tag} eq "default" ? "seek" : $self->{tag};
  $self->{pre3seekfile} = sprintf "/tmp/%s.%s.%s",
      $self->{cfgbase}, $self->{seekfilebase},
      $self->{tag} eq "default" ? "seek" : $self->{tag};
  $self->{pre2seekfile} = sprintf "%s/%s.%s.%s", $self->{seekfilesdir},
      $self->{cfgbase}, $self->{logbasename},
      $self->{tag} eq "default" ? "seek" : $self->{tag};
}

sub force_cfgbase {
  # this is for the -F option. after initialization the seek/protocolfiles
  # must be reset to cfgbase of the base configfile is used
  my $self = shift;
  $self->{cfgbase} = shift;
  $self->construct_seekfile();
}

sub prepare {
  my $self = shift;
  return $self;
}

sub finish {
  my $self = shift;
  return $self;
}


sub run {
  my $self = shift;
  $self->trace(sprintf "==================== %s ==================", $self->{logfile});
  $self->prepare();
  $self->loadstate();
  $self->analyze_situation();
  if ($self->{logrotated} || $self->{logmodified} || $self->{hasinversepat}) {
    # be lazy and examine files only if necessary
    $self->collectfiles();
  }
  if ($self->{hasinversepat} || scalar(@{$self->{relevantfiles}})) {
    $self->scan();
  } else {
    $self->trace("nothing to do");
    # $state keeps the old values
    foreach (keys %{$self->{laststate}}) {
      $self->{newstate}->{$_} = $self->{laststate}->{$_};
    }
    $self->trace("keeping %s", $self->{newstate}->{servicestateid})
        if $self->{newstate}->{servicestateid}; # maybe this was the 1st time
  }
  $self->savestate();
  $self->finish();
  $self->formulate_perfdata();
}

=item loadstate()

    Load the last session's state.
    The state is defined by
    - the position where the last search stopped
    - the time when the logfile was last touched then.
    - device and inode of the logfile (since version 1.4)
    If there is no state file, then this must be the first run of check_logfiles.
    In this case take the current file length as the stop position, so nothing will
    actually be done.

=cut
sub loadstate {
  my $self = shift;
  if (-f $self->{seekfile}) {
    $self->{likeavirgin} = 0;
    $self->trace(sprintf "found seekfile %s", $self->{seekfile});
    our $state = {};
    #eval {
      do $self->{seekfile};
    #};
    if ($@) {
      # found a seekfile with the old syntax
      $self->trace(sprintf "seekfile has old format %s", $@);
      my $seekfh = new IO::File;
      $seekfh->open($self->{seekfile}, "r");
      $self->{laststate} = {
          logoffset => $seekfh->getline() || 0,
          logtime => $seekfh->getline() || 0,
          devino => $seekfh->getline(),
          logfile => $self->{logfile},
      };
      chomp $self->{laststate}->{logoffset} if $self->{laststate}->{logoffset};
      chomp $self->{laststate}->{logtime} if $self->{laststate}->{logtime};
      chomp $self->{laststate}->{devino} if $self->{laststate}->{devino};
      $seekfh->close();
    } else {
      # found a new format seekfile
      $self->{laststate} = $state;
    }
    if (! $self->{laststate}->{logfile}) {
      $self->{laststate}->{logfile} = $self->{logfile};
    }
    if (! $self->{laststate}->{devino}) {
      # upgrade vom < 1.4 on the fly
      $self->{laststate}->{devino} = $self->getfilefingerprint($self->{logfile});
    }
    if (! $self->{laststate}->{servicestateid}) {
      $self->{laststate}->{servicestateid} = 0;
    }
    if (! $self->{laststate}->{serviceoutput}) {
      $self->{laststate}->{serviceoutput} = "OK";
    }
    foreach my $level qw(CRITICAL WARNING UNKNOWN) {
      if (exists $self->{laststate}->{thresholdcnt}->{$level}) {
        $self->{thresholdcnt}->{$level} =
            $self->{laststate}->{thresholdcnt}->{$level};
      }
    }
    $self->trace("LS lastlogfile = %s", $self->{laststate}->{logfile});
    $self->trace("LS lastoffset = %u / lasttime = %d (%s) / inode = %s",
        $self->{laststate}->{logoffset}, $self->{laststate}->{logtime},
        scalar localtime($self->{laststate}->{logtime}),
        $self->{laststate}->{devino});
  } else {
    $self->trace("try pre2seekfile %s instead", $self->{pre2seekfile});
    if (-f $self->{pre2seekfile}) {
      $self->trace("pre-2.0 seekfile %s found. rename it to %s",
          $self->{pre2seekfile}, $self->{seekfile});
      mkdir $self->{seekfilesdir} if ! -d $self->{seekfilesdir};
      rename $self->{pre2seekfile}, $self->{seekfile};
      $self->trace("and call load_state again");
      $self->loadstate() if -f $self->{seekfile};
      return $self;
    }
    $self->trace("try pre3seekfile %s instead", $self->{pre3seekfile});
    if (-f $self->{pre3seekfile}) {
      $self->trace("pre-3.0 seekfile %s found. rename it to %s",
          $self->{pre3seekfile}, $self->{seekfile});
      mkdir $self->{seekfilesdir} if ! -d $self->{seekfilesdir};
      rename $self->{pre3seekfile}, $self->{seekfile};
      $self->trace("and call load_state again");
      $self->loadstate() if -f $self->{seekfile};
      return $self;
    }
    $self->{likeavirgin} = 1;
    $self->trace("no seekfile %s found", $self->{seekfile});
    if (-e $self->{logfile}) {
    	$self->trace(sprintf "but logfile %s found", $self->{logfile});
      #  Fake a "the logfile was not touched" situation.
      $self->{laststate} = {
          logoffset => $self->getfilesize($self->{logfile}),
          logtime => (stat $self->{logfile})[10],
          devino => $self->getfilefingerprint($self->{logfile}),
          logfile => $self->{logfile},
          servicestateid => 0,
          serviceoutput => "OK",
      };
    } else {
    	$self->trace("and no logfile found");
      #  This is true virginity
      $self->{laststate} = {
          logoffset => 0,
          logtime => 0,
          devino => "0:0",
          logfile => $self->{logfile},
          servicestateid => 0,
          serviceoutput => "OK",
      };
    }
    $self->trace("ILS lastlogfile = %s", $self->{laststate}->{logfile});
    $self->trace("ILS lastoffset = %u / lasttime = %d (%s) / inode = %s",
        $self->{laststate}->{logoffset}, $self->{laststate}->{logtime},
        scalar localtime($self->{laststate}->{logtime}), $self->{laststate}->{devino});
  }
  if (exists $self->{laststate}->{privatestate}) {
    $self->{privatestate} = $self->{laststate}->{privatestate};
    $self->trace("found private state %s",
        Data::Dumper::Dumper($self->{privatestate}));
  }
  if (! $self->{laststate}->{runcount}) {
    $self->{laststate}->{runcount} = 1;
  } else {
    $self->{laststate}->{runcount}++;
  }
  if (! $self->{laststate}->{runtime}) {
    $self->{laststate}->{runtime} = 0;
  }
  $self->{privatestate}->{lastruntime} = $self->{laststate}->{runtime};
  $self->{privatestate}->{runcount} = $self->{laststate}->{runcount};
  $self->{macros}->{CL_LAST_RUNTIME} = $self->{privatestate}->{lastruntime};
  $self->{macros}->{CL_RUN_COUNT} = $self->{privatestate}->{runcount};
  return $self;
}


=item savestate()

    Save a session's state. We need this for the next run of check_logfiles.
    Here we remember, how far we read the logfile, when it was last modified
    and what it's inode was.

=cut
sub savestate {
  my $self = shift;
  my $seekfh = new IO::File;
  my $now = time;
  $self->searchresult(); # calculate servicestateid and serviceoutput
  if ($self->{options}->{sticky}) {
    if ($self->{report} ne 'short') {
      $self->{newstate}->{matchlines} = $self->{matchlines};
    }
    if ($self->{laststate}->{servicestateid}) {
      $self->trace("an error level of %s is sticking at me",
          $self->{laststate}->{servicestateid});
      $self->trace("and now i have %s",
          $self->{newstate}->{servicestateid});
      if ($self->{newstate}->{servicestateid}) {
        $self->{newstate}->{laststicked} = $now;
        $self->trace("refresh laststicked");
        # dont forget to count the sticky error
        if ($self->{report} ne 'short') {
          foreach my $level (qw(OK WARNING CRITICAL UNKNOWN)) {
            my $servicestateid =
                {'OK'=>0,'WARNING'=>1,'CRITICAL'=>2,'UNKNOWN'=>3}->{$level};
            foreach my $event (
                reverse @{$self->{laststate}->{matchlines}->{$level}}) {
              $self->addfirstevent($servicestateid, $event);
            }
          }
        } else {
          $self->addfirstevent($self->{laststate}->{servicestateid},
              $self->{laststate}->{serviceoutput});
        }
        if (($self->{newstate}->{servicestateid} == 1) &&
            ($self->{laststate}->{servicestateid} == 2)) {
          # if this was a warning and we already have a sticky critical
          # save the critical as the sticky exitcode
          $self->{newstate}->{servicestateid} =
              $self->{laststate}->{servicestateid};
          # and keep the critical message as output
          $self->{newstate}->{serviceoutput} =
              $self->{laststate}->{serviceoutput};
        }
      } else {
        if ($self->{options}->{sticky} > 1) {
          # we had a stick error, then an ok pattern and no new error
          $self->trace("sticky error was resetted");
          $self->{newstate}->{laststicked} = 0;
          $self->{newstate}->{servicestateid} = 0;
          $self->{newstate}->{serviceoutput} = "";
          if ($self->{report} ne 'short') {
            delete $self->{newstate}->{matchlines};
          }
        } else {
          # newstate is 0 because nothing happened in this scan
          # after maxstickytime do not carry on with this error.
          if (($now - $self->{laststate}->{laststicked}) >
              $self->{maxstickytime}) {
            $self->trace("maxstickytime %d expired", $self->{maxstickytime});
            $self->{newstate}->{laststicked} = 0;
            $self->{newstate}->{servicestateid} = 0;
            $self->{newstate}->{serviceoutput} = "";
            if ($self->{report} ne 'short') {
              delete $self->{newstate}->{matchlines};
            }
          } else {
            $self->{newstate}->{laststicked} =
                $self->{laststate}->{laststicked};
            $self->{newstate}->{servicestateid} =
                $self->{laststate}->{servicestateid};
            $self->{newstate}->{serviceoutput} =
                $self->{laststate}->{serviceoutput};
            $self->trace("stay sticky until %s",
                scalar localtime ($self->{newstate}->{laststicked}
                + $self->{maxstickytime}));
            if ($self->{report} ne 'short') {
              foreach my $level (qw(OK WARNING CRITICAL UNKNOWN)) {
                my $servicestateid =
                  {'OK'=>0,'WARNING'=>1,'CRITICAL'=>2,'UNKNOWN'=>3}->{$level};
                foreach my $event (
                    reverse @{$self->{laststate}->{matchlines}->{$level}}) {
                  $self->addfirstevent($servicestateid, $event);
                }
              }
            } else {
              $self->addevent($self->{newstate}->{servicestateid},
                  $self->{newstate}->{serviceoutput});
            }
          }
        }
      }
    } else {
      $self->trace("no sticky error from last run");
      if ($self->{newstate}->{servicestateid}) {
        $self->{newstate}->{laststicked} = $now;
        $self->trace("stick until %s",
            scalar localtime ($self->{newstate}->{laststicked} +
            $self->{maxstickytime}));
      }
    }
  }
  # save threshold counts if a threshold exists for a level
  if ($self->{options}->{savethresholdcount}) {
    foreach my $level qw(CRITICAL WARNING UNKNOWN) {
      if ($self->{threshold}->{$level}) {
        $self->{newstate}->{thresholdcnt}->{$level} =
            $self->{thresholdcnt}->{$level};
      }
    }
  }
  $self->{newstate}->{tag} = $self->{tag};
  $self->{newstate}->{privatestate} = $self->{privatestate};
  $self->{newstate}->{runcount} = $self->{laststate}->{runcount};
  $self->{newstate}->{runtime} = $now;
  mkdir $self->{seekfilesdir} if ! -d $self->{seekfilesdir};
  if ($seekfh->open($self->{seekfile}, "w")) {
    my $dumpstate = Data::Dumper->new([$self->{newstate}], [qw(state)]);
    #printf("save %s\n", $dumpstate->Dump());
    $dumpstate = Data::Dumper->new([$self->{newstate}], [qw(state)]);
    $seekfh->printf("%s\n", $dumpstate->Dump());
    $seekfh->printf("\n1;\n");
    $seekfh->close();
    $self->trace("keeping position %u and time %d (%s) for inode %s in mind",
        $self->{newstate}->{logoffset}, $self->{newstate}->{logtime},
        scalar localtime($self->{newstate}->{logtime}),
        $self->{newstate}->{devino});
  } else {
    $self->{options}->{count} = 1;
    $self->addevent(WARNING, sprintf "cannot write status file %s",
    $self->{seekfile});
  }
  return $self;
}

sub formulate_perfdata {
  my $self = shift;
  if ($self->{options}->{perfdata}) {
  	if (exists $self->{template} && $self->{dynamictag}) {
  	  $self->{perftag} = $self->{template};
  	} else {
  	  $self->{perftag} = $self->{tag};
  	}
    $self->{perfdata} = sprintf "%s_lines=%d %s_warnings=%d %s_criticals=%d %s_unknowns=%d",
        $self->{perftag}, $self->{linesread},
        $self->{perftag}, scalar(@{$self->{matchlines}->{WARNING}}),
        $self->{perftag}, scalar(@{$self->{matchlines}->{CRITICAL}}),
        $self->{perftag}, scalar(@{$self->{matchlines}->{UNKNOWN}});
  }
}

sub addevent {
  my $self = shift;
  my $level = shift;
  my $errormessage = shift;
  if ($self->{options}->{maxlength}) {
    $errormessage = substr $errormessage, 0, $self->{options}->{maxlength};
  }
  if ($level =~ /^\d/) {
    $level = (qw(OK WARNING CRITICAL UNKNOWN))[$level];
  }
  push(@{$self->{matchlines}->{$level}}, $errormessage);
  $self->{lastmsg}->{$level} =
      ${$self->{matchlines}->{$level}}[$#{$self->{matchlines}->{$level}}];
  #if ($self->{report} ne "short") {
  #  push(@{$self->{history}},
  #      sprintf "%s:%d", $level, scalar(@{$self->{matchlines}->{$level}}) - 1);
  #}
}

sub update_context {
  my $self = shift;
  my $follow = shift;
  my $line = shift;

}

sub addfirstevent {
  my $self = shift;
  my $level = shift;
  my $errormessage = shift;
  if ($level =~ /^\d/) {
    $level = (qw(OK WARNING CRITICAL UNKNOWN))[$level];
  }
  unshift(@{$self->{matchlines}->{$level}}, $errormessage);
  $self->{lastmsg}->{$level} =
      ${$self->{matchlines}->{$level}}[$#{$self->{matchlines}->{$level}}];
  #if ($self->{report} ne "short") {
  #  unshift(@{$self->{history}}, sprintf "%s:%d", $level, 0);
  #}
}

#
#  Read through all files found during analyze_situation and compare
#  the contents with patterns declared critical or warning or....
#
sub scan {
  my $self = shift;
  my $actionfailed = 0;
  my $resetted = 0;
  my $needfilter = scalar(@{$self->{preliminaryfilter}->{NEED}});
  my $skipfilter = scalar(@{$self->{preliminaryfilter}->{SKIP}});
  foreach my $logfile (@{$self->{relevantfiles}}) {
    $self->trace("moving to position %u in %s", $self->{laststate}->{logoffset},
        $logfile->{filename});
    if ($logfile->{seekable}) {
      $logfile->{fh}->seek($self->{laststate}->{logoffset}, 0);
    } else {
      my $buf;
      my $needtoread;
      $logfile->{offset} = 0;
      if ($self->{laststate}->{logoffset} > $self->{max_readsize}) {
        $needtoread = $self->{max_readsize};
        $self->trace("i cannot sysread %u bytes. begin with %u bytes",
            $self->{laststate}->{logoffset}, $needtoread);
      } else {
        $needtoread = $self->{laststate}->{logoffset};
      }
      while ($logfile->{offset} < $self->{laststate}->{logoffset}) {
        $self->trace("i start at offset %u", $logfile->{offset});
        my $bytes = $logfile->{fh}->sysread($buf, $needtoread);
        if (! defined $bytes) {
          $self->trace("read error at position %u", $logfile->{offset});
          last;
        } elsif ($bytes == 0) {
          # this should not happen, but at least it is an exit
          # from an endless loop.
          $self->trace("i read %d bytes. looks like EOF at position %u",
              $bytes, $logfile->{offset});
          last;
        } else {
          $self->trace("i read %d bytes", $bytes);
          $logfile->{offset} += $bytes;
          if (($self->{laststate}->{logoffset} - $logfile->{offset}) >
              $self->{max_readsize}) {
            $needtoread = $self->{max_readsize};
            $self->trace("i cannot sysread %u bytes. continue with %u bytes",
                $self->{laststate}->{logoffset} - $logfile->{offset},
                $needtoread);
          } else {
            $needtoread = $self->{laststate}->{logoffset} - $logfile->{offset};
            $self->trace("i will sysread %u bytes.", $needtoread);
          }
        }
      }
      $self->trace("fake seek positioned at offset %u", $logfile->{offset});
    }
    while (my $line = $logfile->{fh}->getline()) {
      my $filteredout = 0;
      $self->{linesread}++;
      if (! $logfile->{seekable}) { $logfile->{offset} += length($line) }
      if ($self->{options}->{encoding}) {
      	# i am sure this is completely unreliable
      	$line = Encode::encode("ascii",
            Encode::decode($self->{options}->{encoding}, $line));
        # the input stream is somewhat binary, so chomp doesn't know
        # it neads to remove \r\n on windows.
        $line =~ s/$1/\n/g if $line =~ /(\r\n?|\n\r?)/;
      }
      chomp($line);
      #
      #  If for example the prefilter option was set, check if the line
      #  needs to be further examined. Only lines which match the needed filter
      #  can pass.
      #
      if ($needfilter) {
      	foreach my $filter (@{$self->{preliminaryfilter}->{NEED}}) {
      	  if ($line !~ /$filter/) {
      	  	$self->trace(sprintf "no need for %s", $line);
      	  	$filteredout = 1;
      	  	last;
      	  }
      	}
      }
      #
      #  Skip lines with blacklist patterns
      #
      if ($skipfilter) {
      	foreach my $filter (@{$self->{preliminaryfilter}->{SKIP}}) {
      	  if ($line =~ /$filter/) {
      	  	$self->trace(sprintf "skip unwanted %s", $line);
      	  	$self->trace(sprintf "because matching %s", $filter);
      	  	$filteredout = 1;
      	  	last;
      	  }
      	}
      }
      next if $filteredout;
      $self->{linenumber}++;
      $self->update_context(0, $line); # store this line as before
      foreach my $nagioslevel qw(CRITICAL WARNING UNKNOWN) {
        my $level = $nagioslevel; # because it needs to be modified
        my $outplayed = 0;
        foreach my $exception (@{$self->{exceptions}->{$level}}) {
          if ($line =~ /$exception/) {
            $self->trace("exception %s found. aborting.", $exception);
            $outplayed = 1;
            last;
          }
        }
        next if $outplayed;
        my $patcnt = -1;
        foreach my $pattern (@{$self->{patterns}->{$level}}) {
          $patcnt++;
          if ($line =~ /$pattern/) {
            $self->trace("MATCH %s %s with %s", $level, $pattern, $line);
            if ($self->{threshold}->{$level}) {
              if ($self->{thresholdcnt}->{$level} <
                  $self->{threshold}->{$level}) {
                $self->trace("skip match and the next %d",
                    $self->{threshold}->{$level} -
                    $self->{thresholdcnt}->{$level});
                $self->{thresholdcnt}->{$level}++;
                next;
              } else {
                $self->{thresholdcnt}->{$level} = 0;
              }
            }
            if ($self->{tivoli}->{object}) {
              $self->{tivoli}->{match} =
                  $self->{tivoli}->{object}->match($line);
              $self->{privatestate}->{tivolimatch} = $self->{tivoli}->{match};
              $level = (qw(OK WARNING CRITICAL UNKNOWN))[$self->{tivoli}->{match}->{exit_code}];
              next if $level eq 'OK';
              $line = $self->{tivoli}->{match}->{subject};
            }
            if ($self->{options}->{script}) {
              $self->{macros}->{CL_SERVICESTATE} = $level;
              $self->{macros}->{CL_SERVICESTATEID} = $ERRORS{$level};
              $self->{macros}->{CL_SERVICEOUTPUT} = $line;
              $self->{macros}->{CL_PATTERN_NUMBER} = $patcnt;
              my ($actionsuccess, $actionrc, $actionoutput) =
                  $self->action($self->{script}, $self->{scriptparams},
                  $self->{scriptstdin}, $self->{scriptdelay},
                  $self->{options}->{smartscript}, $self->{privatestate});
              if (! $actionsuccess) {
              	# note the script failure. multiple failures will generate
              	# one single event in the end.
                $actionfailed = 1;
                $self->addevent($level, $line);
              } elsif ($self->{options}->{supersmartscript}) {
              	# completely replace the matched line with the script output
                $self->addevent($actionrc, $actionoutput);
              } elsif ($self->{options}->{smartscript}) {
              	# both matched line and script output are events
                $self->addevent($level, $line);
                $self->addevent($actionrc, $actionoutput);
              } else {
              	# dumb scripts generate no events. only the matched line.
                $self->addevent($level, $line);
              }
            } else {
              $self->addevent($level, $line);
            }
            if ($self->{tivoli}->{object}) {
              delete $self->{privatestate}->{tivolimatch};
            }
          }
        }
        #  count patterns which raise an alert only if they were not found.
        $patcnt = -1;
        foreach my $pattern (@{$self->{negpatterns}->{$level}}) {
          $patcnt++;
          if ($line =~ /$pattern/) {
            $self->{negpatterncnt}->{$level}->[$patcnt]++;
            $self->trace("negative pattern %s found.", $pattern);
          }
        }
      }
      # maybe a okpattern wipes out the history
      foreach my $pattern (@{$self->{patterns}->{OK}}) {
        if ($line =~ /$pattern/) {
          $self->trace("remedy pattern %s wipes out previous errors",
              $pattern);
          $self->{options}->{sticky}++ if $self->{options}->{sticky};
          # such a remedypattern neutralizes previous error
          $self->{matchlines}->{WARNING} = [];
          $self->{matchlines}->{CRITICAL} = [];
          $self->{matchlines}->{UNKNOWN} = [];
          last;
        }
      }
    }
    #
    #  if there are more files to come, start searching at the beginning
    #  of each file.
    #  only the first (oldest) file will be positioned at an offset.
    #
    $self->{laststate}->{logoffset} = 0;
    $self->{newstate}->{logoffset} = $logfile->{seekable} ?
        $logfile->{fh}->tell() : $logfile->{offset};
    $self->{newstate}->{logtime} = (stat $logfile->{fh})[9];
    $self->{newstate}->{devino} = $self->getfilefingerprint($logfile->{fh});
    $self->trace("stopped reading at position %u",
        $self->{newstate}->{logoffset});
  }
  #
  #  if patterns beginning with ! were not found, treat this as an alert.
  #
  if ($self->{hasinversepat}) {
    foreach my $level qw(CRITICAL WARNING) {
      my $patcnt = -1;
      foreach my $pattern (@{$self->{negpatterns}->{$level}}) {
        $patcnt++;
        if ($self->{negpatterncnt}->{$level}->[$patcnt] == 0) {
          if ($self->{options}->{script}) {
            $self->{macros}->{CL_SERVICESTATEID} = $ERRORS{$level};
            $self->{macros}->{CL_SERVICEOUTPUT} = sprintf("MISSING: %s", $pattern);
            $self->{macros}->{CL_PATTERN_NUMBER} = $patcnt;
            my ($actionsuccess, $actionrc, $actionoutput) =
                $self->action($self->{script}, $self->{scriptparams},
                $self->{scriptstdin}, $self->{scriptdelay},
                $self->{options}->{smartscript}, $self->{privatestate});
            if (! $actionsuccess) {
              $actionfailed = 1;
      	      $self->addevent($level, sprintf("MISSING: %s", $pattern));
            } elsif ($self->{options}->{supersmartscript}) {
              $self->addevent($actionrc, $actionoutput);
            } elsif ($self->{options}->{smartscript}) {
              $self->addevent($level, sprintf("MISSING: %s", $pattern));
              $self->addevent($actionrc, $actionoutput);
            } else {
              $self->addevent($level, sprintf("MISSING: %s", $pattern));
            }
          } else {
      	    $self->addevent($level, sprintf("MISSING: %s", $pattern));
          }
        }
      }
    }
    #
    #  no files were examined, so no positioning took place.
    #  keep the old status.
    #
    if (scalar @{$self->{relevantfiles}} == 0) {
      $self->{newstate}->{logoffset} = $self->{laststate}->{logoffset};
      $self->{newstate}->{logtime} = $self->{laststate}->{logtime};
      $self->{newstate}->{devino} = $self->{laststate}->{devino};
    }
  }
  #
  #  now the heavy work is done. logfiles were searched and matching lines
  #  were found and noted.
  #  close the open file handles and store the current position in a seekfile.
  #
  foreach my $logfile (@{$self->{relevantfiles}}) {
    $logfile->{fh}->close();
  }
  if ((scalar @{$self->{relevantfiles}} > 0) && ($self->{logfile} ne
      @{$self->{relevantfiles}}[$#{$self->{relevantfiles}}]->{filename})) {
    #
    #  only rotated files were examined and a new logfile was not created yet.
    #  next time we hopefully will have a new logfile, so start at position 0.
    #  set the lastlogtime to now, and don't care no longer for the past.
    #
    $self->trace("rotated logfiles examined but no current logfile found");
    $self->{newstate}->{logoffset} = 0;
    $self->{newstate}->{logtime} = time;
  }
  if ($actionfailed) {
    $self->{options}->{count} = 1;
    push(@{$self->{matchlines}->{WARNING}},
        sprintf "could not execute %s", $self->{script});
  }
}

sub addfilter {
  my $self = shift;
  my $need = shift;
  my $pattern = shift;
  if ($need) {
    push(@{$self->{preliminaryfilter}->{NEED}}, $pattern);
  } else {
    push(@{$self->{preliminaryfilter}->{SKIP}}, $pattern);
  }
}

sub searchresult {
  my $self = shift;
  if (scalar @{$self->{matchlines}->{CRITICAL}}) {
  	$self->{newstate}->{servicestateid} = 2;
  	$self->{newstate}->{serviceoutput} =
  	    ${$self->{matchlines}->{CRITICAL}}[$#{$self->{matchlines}->{CRITICAL}}];
  } elsif (scalar @{$self->{matchlines}->{WARNING}}) {
  	$self->{newstate}->{servicestateid} = 1;
  	$self->{newstate}->{serviceoutput} =
  	    ${$self->{matchlines}->{WARNING}}[$#{$self->{matchlines}->{WARNING}}];
  } elsif (scalar @{$self->{matchlines}->{UNKNOWN}}) {
    $self->{newstate}->{servicestateid} = 3;
  	$self->{newstate}->{serviceoutput} =
  	    ${$self->{matchlines}->{UNKNOWN}}[$#{$self->{matchlines}->{UNKNOWN}}];
  } else {
  	$self->{newstate}->{servicestateid} = 0;
  	$self->{newstate}->{serviceoutput} = "";
  }
  if ($self->{option}->{sticky} && $self->{report} ne 'short') {
    # damit long/html output erhalten bleibt und nicht nur der letzte treffer
    $self->{newstate}->{matchlines} = $self->{matchlines};
  }
}

sub reset {
  my $self = shift;
  $self->{matchlines} = { OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [] };
  $self->{lastmsg} = { OK => "", WARNING => "", CRITICAL => "", UNKNOWN => "" };
  $self->{negpatterncnt} = { OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [] };
  $self->{thresholdcnt} = { OK => 0, WARNING => 0, CRITICAL => 0, UNKNOWN => 0 };
  #$self->{preliminaryfilter} = { SKIP => [], NEED => [] };
  $self->{perfdata} = "";
  foreach my $level qw(CRITICAL WARNING UNKNOWN) {
    foreach my $pat (@{$self->{negpatterns}->{$level}}) {
      push(@{$self->{negpatterncnt}->{$level}}, 0);
    }
  }
  if (exists $self->{template} && exists $self->{dynamictag}) {
    $self->{macros}->{CL_TAG} = $self->{dynamictag};
    $self->{macros}->{CL_TEMPLATE} = $self->{template};
  } else {
    #$self->resolve_macros(\$self->{tag});
    $self->{macros}->{CL_TAG} = $self->{tag};
  }
  delete $self->{lastlogoffset};
  delete $self->{lastlogtime};
  delete $self->{lastlogoffset};
  delete $self->{lastlogfile};
  delete $self->{newlogoffset};
  delete $self->{newlogtime};
  delete $self->{newdevino};
  delete $self->{newlogfile};
  $self->{relevantfiles} = [];
  $self->{logrotated} = 0;
  $self->{logmodified} = 0;
  $self->{linesread} = 0;
  $self->{relevantfiles} = [];
  if (exists $self->{options}->{sticky}) {
    $self->{options}->{sticky} = 1 if ($self->{options}->{sticky} > 1);
  }
  return $self;
}


package Nagios::CheckLogfiles::Search::Simple;

use strict;
use Exporter;
use File::Basename;
use vars qw(@ISA);

use constant OK => 0;
use constant WARNING => 1;
use constant CRITICAL => 2;
use constant UNKNOWN => 3;

@ISA = qw(Nagios::CheckLogfiles::Search);

sub new {
  my $self = bless {}, shift;
  return $self->init(shift);
}

sub analyze_situation {
  my $self = shift;
  $self->{logrotated} = 0;
  $self->{logmodified} = 0;

  if (! -e $self->{logfile}) {
    #
    #  the logfile was deleted and no new events occurred since.
    #  todo: no collection, but reset counters, incl. timestamp
    #  with the modified flag we force a call to collectfiles where
    #  [no]logfilenocry will be considered.
    $self->{logmodified} = 1;
    $self->trace(sprintf "there is no logfile %s at this moment",
        $self->{logfile});
    $self->{laststate}->{logoffset} = 0;
  } elsif (! $self->getfileisreadable($self->{logfile})) {
    $self->{logmodified} = 1;
    $self->trace(sprintf "first noticed that logfile %s is unreadable",
        $self->{logfile});
  } elsif ($self->{laststate}->{devino} ne
        $self->getfilefingerprint($self->{logfile})) {
    # the inode changed (! the old inode could have been reused)
    # or maybe this is the first time this logfile was seen
    $self->trace(sprintf "this is not the same logfile %s %s != %s",
        $self->{logfile}, $self->{laststate}->{devino},
        $self->getfilefingerprint($self->{logfile}));
    $self->{logmodified} = 1;
    $self->{laststate}->{logoffset} = 0;
    $self->trace(sprintf "reset to offset 0");
  } elsif ($self->getfilesize($self->{logfile}) >
        $self->{laststate}->{logoffset}) {
    #
    #  the logfile grew.
    #  this is the normal behaviour. in rare cases the logfile could have been
    #  rotated/recreated and grown very fast.
    $self->trace(sprintf "the logfile grew to %d",
        $self->getfilesize($self->{logfile}));
    if ($self->{likeavirgin}) {
      # if the logfile grew because we initialized the plugin with an offset of 0, position
      # at the end of the file and skip this search. otherwise lots of outdated messages could
      # match and raise alerts.
      $self->{laststate}->{logoffset} = $self->getfilesize($self->{logfile});
    } else {
      $self->{logmodified} = 1;
      # this is only relevant if
      # 1.a new logfile is created using the same inode as the deleted logfile
      # 2.the new logfile grew beyond the size of the last logfile before check_logfile ran
      #if ($self->{firstline} ne $self->{laststate}->{firstline}) {
      #	$self->trace(sprintf "a new logfile grew beyond the end of the last logfile");
      #	$self->{laststate}->{logoffset} = 0;
      #}
    }
  } elsif ($self->getfilesize($self->{logfile}) == 0) {
  	#
  	#  the logfile was either truncated or deleted and touched.
  	#  nothing to do except reset the position
    $self->{logmodified} = 0;
    $self->{laststate}->{logoffset} = 0;
    $self->{laststate}->{logtime} = (stat $self->{logfile})[9];
    $self->trace("logfile has been truncated");
  } elsif ($self->getfilesize($self->{logfile}) <
        $self->{laststate}->{logoffset}) {
    #
    #  logfile shrunk. either it was truncated or it was
    #  rotated and a new logfile was created.
    $self->trace(sprintf "the logfile shrunk from %d to %d",
        $self->{laststate}->{logoffset}, $self->getfilesize($self->{logfile}));
    $self->{logmodified} = 1;
    $self->{laststate}->{logoffset} = 0;
    $self->trace(sprintf "reset to offset 0");
  } elsif ($self->getfilesize($self->{logfile}) ==
        $self->{laststate}->{logoffset}) {
  	$self->trace(sprintf "the logfile did not change");
  } else {
    $self->trace("I HAVE NO IDEA WHAT HAPPENED");
  }
  return $self;
}

sub collectfiles {
  my $self = shift;
  my @rotatedfiles = ();
  if ($self->{logmodified}) {
  	my $fh = new IO::File;
    # cygwin lets you open files even after chmodding them to 0000, so double check with -r
    if ($self->getfileisreadable($self->{logfile})) {
      $fh->open($self->{logfile}, "r");
      $self->trace("opened logfile %s", $self->{logfile});
      push(@rotatedfiles,
          { filename => $self->{logfile}, fh => $fh, seekable => 1 });
      $self->trace("logfile %s (modified %s / accessed %s / inode %d / inode changed %s)",
          $self->{logfile},
          scalar localtime((stat $self->{logfile})[9]),
          scalar localtime((stat $self->{logfile})[8]),
          (stat $self->{logfile})[1],
          scalar localtime((stat $self->{logfile})[10]));
    } else {
      if (-e $self->{logfile}) {
        #  permission problem
        $self->trace("could not open logfile %s", $self->{logfile});
        $self->addevent('CRITICAL', sprintf "could not open logfile %s",
            $self->{logfile});
      } else {
      	if ($self->{options}->{logfilenocry}) {
      	  # logfiles which are not rotated but deleted and re-created may be missing
          #  maybe a rotation situation, a typo in the configfile,...
          $self->trace("could not find logfile %s", $self->{logfile});
          $self->addevent('UNKNOWN', sprintf "could not find logfile %s",
              $self->{logfile});
        } else {
      	  # dont care.
      	  $self->trace("could not find logfile %s, but that's ok",
              $self->{logfile});
        }
      }
    }
  }
  $self->trace(sprintf "relevant files: %s", join(", ", map { basename $_->{filename} } @rotatedfiles));
  $self->{relevantfiles} = \@rotatedfiles;
}


package Nagios::CheckLogfiles::Search::Rotating;

use strict;
use Exporter;
use File::Basename;
use vars qw(@ISA);

use constant OK => 0;
use constant WARNING => 1;
use constant CRITICAL => 2;
use constant UNKNOWN => 3;

@ISA = qw(Nagios::CheckLogfiles::Search);

sub new {
  my $self = bless {}, shift;
  # sollte mal raus, da gibts kein sub dazu.
  # hier kommt eh keiner her, weil eins hoeher geblesst wird
  # $self->rotationpattern();
  return $self->init(shift);
}

sub analyze_situation {
  my $self = shift;
  $self->{logrotated} = 0;
  $self->{logmodified} = 0;
  if (! $self->{NH_detection}) {
    if (! -e $self->{logfile}) {
      #
      #  if no logfile exists, then probably it was rotated and no new logs
      #  were written since.
      #  find files which were modified after $lasttime. the most recent one
      #  is probably the former logfile. position at $lastoffset.
      #  if this configurations does not care for rotations, there is nothing
      #  we can do here.
      #
      $self->{logrotated} = 1;
      $self->{logmodified} = 1;
      $self->trace(sprintf "there is no logfile %s at this moment",
          $self->{logfile});
    } elsif ($self->{laststate}->{devino} ne
          $self->getfilefingerprint($self->{logfile})) {
      # the inode changed (! the old inode could be reused)
      $self->trace(sprintf "this is not the same logfile %s != %s",
          $self->{laststate}->{devino},
          $self->getfilefingerprint($self->{logfile}));
      $self->{logrotated} = 1;
      $self->{logmodified} = 1;
    } elsif ($self->getfilesize($self->{logfile}) >
          $self->{laststate}->{logoffset}) {
      #
      #  the logfile grew.
      #  this is the normal behaviour. in rare cases the logfile could have been
      #  rotated/recreated and grown very fast.
      $self->trace(sprintf "the logfile grew to %d",
          $self->getfilesize($self->{logfile}));
      if ($self->{likeavirgin}) {
        # if the logfile grew because we initialized the plugin with an offset of 0, position
        # at the end of the file and skip this search. otherwise lots of outdated messages could
        # match and raise alerts.
        $self->{laststate}->{logoffset} = $self->getfilesize($self->{logfile});
      } else {
        $self->{logmodified} = 1;
      }
    } elsif ($self->getfilesize($self->{logfile}) == 0) {
    	#
    	#  the logfile was either truncated or deleted and touched.
    	#  nothing to do except reset the position
      $self->{logrotated} = 1;
      $self->{laststate}->{logtime} = (stat $self->{logfile})[9];
    } elsif ($self->getfilesize($self->{logfile}) <
          $self->{laststate}->{logoffset}) {
      #
      #  logfile shrunk. either it was truncated or it was
      #  rotated and a new logfile was created.
      $self->trace(sprintf "the logfile shrunk from %d to %d",
          $self->{laststate}->{logoffset}, $self->getfilesize($self->{logfile}));
      $self->{logmodified} = 1;
      $self->{logrotated} = 1;
    } elsif ($self->getfilesize($self->{logfile}) ==
          $self->{laststate}->{logoffset}) {
      $self->trace(sprintf "the logfile did not change");
    } else {
      $self->trace("I HAVE NO IDEA WHAT HAPPENED");
    }
    return $self;
  } else {
    # Nigel Harnimans mtime-based algorithm
    my $filetime = (stat $self->{logfile})[9];
    my $lastfiletime = $self->{laststate}->{logtime};

    if (! -e $self->{logfile}) {
      #
      #  if no logfile exists, then probably it was rotated and no new logs
      #  were written since.
      #  find files which were modified after $lasttime. the most recent one
      #  is probably the former logfile. position at $lastoffset.
      #  if this configurations does not care for rotations, there is nothing
      #  we can do here.
      #
      $self->{logrotated} = 1;
      $self->{logmodified} = 1;
      $self->trace(sprintf "there is no logfile %s at this moment",
          $self->{logfile});
    } elsif ($self->{laststate}->{devino} ne
          $self->getfilefingerprint($self->{logfile})) {
      # the inode changed (! the old inode could be reused)
      $self->trace(sprintf "this is not the same logfile %s != %s",
          $self->{laststate}->{devino},
          $self->getfilefingerprint($self->{logfile}));
      $self->{logrotated} = 1;
      $self->{logmodified} = 1;

      # Ok, we need to make some changes here to handle a situation where the
      # inode is not changed on file rotation (since the writing app need
      # continuity)
      # 1)    The last modified time is the same as that of the previously scanned
      #       log file. Therefore it is the same file. No rotation or modification
      # 2)    The last modified time is different, and the file is zero bytes:
      #       - Modified = false
      #       - Rotated = true
      # 3)    The last modified time is different, and the file is not zero bytes
      #       and is less than previous:
      #       - Modified = true
      #       - Rotated = true
      # 4)    The last modified time is different, and the file is not zero bytes
      #       and is more than previous:
      #       - Modified = true
      #       - Rotated = true (we can't actually tell, so need to play safe)
    } elsif ($filetime == $lastfiletime) {
      $self->trace(sprintf "Log file has the same modified time: %s ",
          scalar localtime($filetime));
      $self->{laststate}->{logtime} = $filetime;
    } elsif ($filetime != $lastfiletime) {
      $self->trace(sprintf "Log file modified time: %s, last modified time: %s",
          scalar localtime($filetime),
          scalar localtime($lastfiletime));
      if ($self->getfilesize($self->{logfile}) == 0) {
        $self->trace(sprintf "Log file is zero bytes");
        $self->{logrotated} = 1;
      } else {
        $self->trace(sprintf "Log file is not zero bytes");
        $self->{logrotated} = 1;
        $self->{logmodified} = 1;
      }
    } else {
      $self->trace("I HAVE NO IDEA WHAT HAPPENED");
    }
    $self->trace(sprintf "Log offset: %i",
        $self->{laststate}->{logoffset});
    return $self;
  }
}


sub collectfiles {
  my $self = shift;
  my @rotatedfiles = ();
  if ($self->{logrotated} && $self->{rotation}) {
    $self->trace("looking for rotated files in %s with pattern %s",
        $self->{archivedir}, $self->{filenamepattern});
    opendir(DIR, $self->{archivedir});
    # read the filenames from DIR, match the filenamepattern, check the file age
    # open the file and return the handle
    # sort the handles by modification time
    #@rotatedfiles = sort { (stat $a->{fh})[9] <=> (stat $b->{fh})[9] } map {
    @rotatedfiles = sort { $a->{modtime} <=> $b->{modtime} } map {
      if (/^$self->{filenamepattern}/) {
        my $archive = sprintf "%s/%s", $self->{archivedir}, $_;
        $self->trace("archive %s matches (modified %s / accessed %s / inode %d / inode changed %s)", $archive,
            scalar localtime((stat $archive)[9]),
            scalar localtime((stat $archive)[8]),
            (stat $archive)[1],
            scalar localtime((stat $archive)[10]));
        if ((stat $self->{archivedir}.'/'.$_)[9] >=
            $self->{laststate}->{logtime}) {
          $self->trace("archive %s was modified after %s", $archive,
              scalar localtime($self->{laststate}->{logtime}));
          my $fh = new IO::File;
          if (/.*\.gz\s*$/) {
            $self->trace("uncompressing %s with gzip -dc < %s|", $archive,
                $archive);
            if ($fh->open('gzip -dc < '.$archive.'|')) {
              ({ filename => $archive,
                  fh => $fh, seekable => 0,
                  modtime => (stat $archive)[9],
                  fingerprint => $self->getfilefingerprint($archive).':'.$self->getfilesize($archive) });
            } else {
              $self->trace("archive %s cannot be opened with gzip", $archive);
              ();
            }
          } elsif (/.*\.bz2\s*$/) {
            $self->trace("uncompressing %s with bzip2 -d < %s|", $archive,
                $archive);
            if ($fh->open('bzip2 -d < '.$archive.'|')) {
              ({ filename => $archive,
                  fh => $fh, seekable => 0,
                  modtime => (stat $archive)[9],
                  fingerprint => $self->getfilefingerprint($archive).':'.$self->getfilesize($archive) });
            } else {
              $self->trace("archive %s cannot be opened with bzip2", $archive);
              ();
            }
          } else {
            if ($fh->open($archive, "r")) {
              ({ filename => $archive,
                  fh => $fh, seekable => 1,
                  size => $self->getfilesize($fh),
                  modtime => (stat $archive)[9],
                  fingerprint => $self->getfilefingerprint($archive).':'.$self->getfilesize($archive) });
            } else {
              $self->trace("archive %s cannot be opened", $_);
              ();
            }
          }
        } else {
          ();
        }
      } else {
        ();
      }
    } readdir(DIR);
    closedir(DIR);
    if (scalar(@rotatedfiles) == 0) {
      #
      #  although a logfile rotation was detected, no archived files were found.
      #  start seeking at position 0.
      #
      if (! $self->{NH_detection}) {
        $self->{laststate}->{logoffset} = 0;
      } else {
        # NH Commented this out, as we may find no rotated files,
        # in which case we need to use the current file offset again
      }
      $self->trace("although a logfile rotation was detected, no archived files were found");
    }
  }
  if ($self->{logmodified}) {
  	my $fh = new IO::File;
    # cygwin lets you open files even after chmodding them to 0000, so double check with -r
    if ($self->getfileisreadable($self->{logfile})) {
      $fh->open($self->{logfile}, "r");
      $self->trace("opened logfile %s", $self->{logfile});
      push(@rotatedfiles,
          { filename => $self->{logfile}, fh => $fh, seekable => 1,
          size => $self->getfilesize($self->{logfile}),
          fingerprint => $self->getfilefingerprint($self->{logfile}).':'.$self->getfilesize($self->{logfile}) });
      $self->trace("logfile %s (modified %s / accessed %s / inode %d / inode changed %s)",
          $self->{logfile},
          scalar localtime((stat $self->{logfile})[9]),
          scalar localtime((stat $self->{logfile})[8]),
          (stat $self->{logfile})[1],
          scalar localtime((stat $self->{logfile})[10]));
    } else {
      if (-e $self->{logfile}) {
        #  permission problem
        $self->trace("could not open logfile %s", $self->{logfile});
        $self->addevent('CRITICAL', sprintf "could not open logfile %s",
            $self->{logfile});
      } else {
      	if ($self->{options}->{logfilenocry}) {
      	  # logfiles which are not rotated but deleted and re-created may be missing
          #  maybe a rotation situation, a typo in the configfile,...
          $self->trace("could not find logfile %s", $self->{logfile});
          $self->addevent('UNKNOWN', sprintf "could not find logfile %s",
              $self->{logfile});
       	} else {
      	  # dont care.
      	  $self->trace("could not find logfile %s, but that's ok", $self->{logfile});
        }
      }
    }
  }
  # now we have an array of structures each pointing to a file
  # which has been rotated since the last scan plus the current logfile.
  # the array members are sorted by modification time of the files.
  # now duplicate entries are removed. in one scenario the current logfile is
  # a symbolic link to a file which uses the same naming schema as the rotated
  # logfiles.
  $self->trace(sprintf "first relevant files: %s", join(", ", map { basename $_->{filename} } @rotatedfiles));
  my %seen = ();
  @rotatedfiles = reverse map {
    $self->trace("%s has fingerprint %s", $_->{filename}, $_->{fingerprint});
    # because of the windows dummy devino 0:0, we need to add the size
    if (exists $seen{$_->{fingerprint}}) {
      $self->trace("skipping %s (identical to %s)",
          $_->{filename}, $seen{$_->{fingerprint}});
      ();
    } else {
      $seen{$_->{fingerprint}} = $_->{filename};
      $_;
    }
  } reverse @rotatedfiles;
  if (@rotatedfiles && (exists $rotatedfiles[0]->{size}) &&
      ($rotatedfiles[0]->{size} < $self->{laststate}->{logoffset})) {
    $self->trace(sprintf "file %s is too short (%d < %d). this should not happen. reset",
        $rotatedfiles[0]->{filename},
        $rotatedfiles[0]->{size}, $self->{laststate}->{logoffset});
    if ($self->{NH_detection}) {
      # NH In this case, we have replaced the files, so set to beginning
      $self->{laststate}->{logoffset} = 0;
    } else {
      $self->{laststate}->{logoffset} = $rotatedfiles[0]->{size};
    }
  }
  $self->trace(sprintf "relevant files: %s", join(", ", map { basename $_->{filename} } @rotatedfiles));
  $self->{relevantfiles} = \@rotatedfiles;
}

sub prepare {
  my $self = shift;
  if ("LOGLOGDATE8GZ" eq uc($self->{rotation})) {
    $self->{filenamepattern} = sprintf '^%s[\.\-]{0,1}[0-9]{8}\.gz$',
        $self->{logbasename};
  } elsif ("LOGLOGDATE8BZ2" eq uc($self->{rotation})) {
    $self->{filenamepattern} = sprintf '^%s[\.\-]{0,1}[0-9]{8}\.bz2$',
        $self->{logbasename};
  } elsif ("LOGLOG0LOG1GZ" eq uc($self->{rotation})) {
    $self->{filenamepattern} = sprintf '^%s\.((0)|([1-9]+\.gz))$',
        $self->{logbasename};
  } elsif ("LOGLOG0GZLOG1GZ" eq uc($self->{rotation})) {
    $self->{filenamepattern} = sprintf '^%s\.((0)|([1-9]+[0-9]*))\.gz$',
        $self->{logbasename};
  } elsif ("LOGLOG0LOG1" eq uc($self->{rotation})) {
    $self->{filenamepattern} = sprintf '^%s\.((0)|([1-9]+[0-9]*))$',
        $self->{logbasename};
  } elsif ("SUSE" eq uc($self->{rotation})) {
    $self->{filenamepattern} = sprintf "%s.*[0-9]*.gz", $self->{logbasename};
  } elsif ("DEBIAN" eq uc($self->{rotation})) {
    $self->{filenamepattern} = sprintf "%s.0|%s.*[0-9]*.gz",
        $self->{logbasename}, $self->{logbasename};
  } elsif ("QMAIL" eq uc($self->{rotation})) {
    $self->{filenamepattern} = "\@.*";
  } elsif ("LOGROTATE" eq uc($self->{rotation})) {
    $self->{filenamepattern} = sprintf "%s.*[0-9]*.gz", $self->{logbasename};
  } elsif ("SOLARIS" eq uc($self->{rotation})) {
    $self->{filenamepattern} = sprintf "%s.*\\.[0-9]+", $self->{logbasename};
  } elsif ("HPUX" eq uc($self->{rotation})) {
    $self->{filenamepattern} = sprintf "OLD%s", $self->{logbasename};
  } elsif ("BMWHPUX" eq uc($self->{rotation})) {
    $self->{filenamepattern} = sprintf 'OLD%s|%s\\.[A-Z][0-9]+_[0-9]+\\.gz$',
        $self->{logbasename}, $self->{logbasename};
  } elsif ("MOD_LOG_ROTATE" eq uc($self->{rotation})) {
    $self->{filenamepattern} = sprintf 'access\.log\.\d{10}';
    bless $self, "Nagios::CheckLogfiles::Search::Rotating::Uniform";
    $self->prepare();
  } else {
    $self->{filenamepattern} = $self->{rotation};
    $self->resolve_macros_in_pattern(\$self->{filenamepattern});
  }
  return $self;
}




package Nagios::CheckLogfiles::Search::Rotating::Uniform;

use strict;
use Exporter;
use File::Basename;
use vars qw(@ISA);

use constant OK => 0;
use constant WARNING => 1;
use constant CRITICAL => 2;
use constant UNKNOWN => 3;

@ISA = qw(Nagios::CheckLogfiles::Search::Rotating);

sub new {
  my $self = bless {}, shift;
  return $self->init(shift);
}

sub prepare {
  my $self = shift;
  my $params = shift;
  my @matchingfiles = ();
  if (! $self->{filenamepattern}) {
    $self->{filenamepattern} = $self->{rotation};
    $self->resolve_macros_in_pattern(\$self->{filenamepattern});
  }
  # find newest rotatingpattern = logfile
  opendir(DIR, $self->{archivedir});
  @matchingfiles = sort { $a->{modtime} <=> $b->{modtime} } map {
      if (/^$self->{filenamepattern}/) {
        my $archive = sprintf "%s/%s", $self->{archivedir}, $_;
       ({ filename => $archive, modtime => (stat $archive)[9]});
      } else {
        ();
      }
  } readdir(DIR);
  closedir(DIR);
  if (@matchingfiles) {
    $self->{logfile} = $matchingfiles[-1]->{filename};
    $self->{macros}->{CL_LOGFILE} = $self->{logfile};
    $self->trace("the newest uniform logfile i found is %s", $self->{logfile});
  } else {
    $self->{logfile} = $self->{archivedir}.'/logfilenotfound';
    $self->trace("i found no uniform logfiles in %s", $self->{archivedir});
  }
  $self->construct_seekfile();
}

sub construct_seekfile {
  my $self = shift;
  # modify seekfilename so it can be found even if the logfile has changed
  $self->{logbasename} = basename($self->{logfile});
  $self->{seekfilebase} = dirname($self->{logfile}).'/uniformlogfile';
  $self->{seekfilebase} =~ s/\//_/g;
  $self->{seekfilebase} =~ s/\\/_/g;
  $self->{seekfilebase} =~ s/:/_/g;
  $self->{seekfilebase} =~ s/\s/_/g;
  $self->{seekfile} = sprintf "%s/%s.%s.%s", $self->{seekfilesdir},
      $self->{cfgbase}, $self->{seekfilebase},
      $self->{tag} eq "default" ? "seek" : $self->{tag};
  $self->{pre3seekfile} = sprintf "/tmp/%s.%s.%s",
      $self->{cfgbase}, $self->{seekfilebase},
      $self->{tag} eq "default" ? "seek" : $self->{tag};
  $self->{pre2seekfile} = sprintf "%s/%s.%s.%s", $self->{seekfilesdir},
      $self->{cfgbase}, $self->{logbasename},
      $self->{tag} eq "default" ? "seek" : $self->{tag};
  $self->trace("rewrote uniform seekfile to %s", $self->{seekfile});
  return $self;
}


package Nagios::CheckLogfiles::Search::Virtual;

use strict;
use Exporter;
use File::Basename;
use vars qw(@ISA);

use constant OK => 0;
use constant WARNING => 1;
use constant CRITICAL => 2;
use constant UNKNOWN => 3;

@ISA = qw(Nagios::CheckLogfiles::Search);

sub new {
  my $self = bless {}, shift;
  return $self->init(shift);
}

sub loadstate {
  my $self = shift;
  $self->{laststate}->{logoffset} = 0;
}

sub savestate {
}

sub analyze_situation {
  my $self = shift;
  $self->{logmodified} = 1;
}

sub collectfiles {
  my $self = shift;
  my @rotatedfiles = ();
  my $fh = new IO::File;
  if ($self->getfileisreadable($self->{logfile})) {
    $fh->open($self->{logfile}, "r");
    $self->trace("opened logfile %s", $self->{logfile});
    push(@rotatedfiles,
        { filename => $self->{logfile}, fh => $fh, seekable => 1 });
  } else {
    if (-e $self->{logfile}) {
      #  permission problem
      $self->trace("could not open logfile %s", $self->{logfile});
      $self->addevent('CRITICAL', sprintf "could not open logfile %s",
          $self->{logfile});
    } else {
      if ($self->{options}->{logfilenocry}) {
        $self->trace("could not find logfile %s", $self->{logfile});
        $self->addevent('UNKNOWN', sprintf "could not find logfile %s",
            $self->{logfile});
      } else {
        # dont care.
        $self->trace("could not find logfile %s, but that's ok",
            $self->{logfile});
      }
    }
  }
  $self->{relevantfiles} = \@rotatedfiles;
}


package Nagios::CheckLogfiles::Search::Prescript;

use strict;
use Exporter;
use File::Basename;
use vars qw(@ISA);

@ISA = qw(Nagios::CheckLogfiles::Search);

sub new {
  my $self = bless {}, shift;
  return $self->init(shift);
}

sub init {
  my $self = shift;
  my $params = shift;
  $self->{tag} = "prescript";
  $self->{scriptpath} = $params->{scriptpath};
  $self->{macros} = $params->{macros};
  $self->{tracefile} = $params->{tracefile};
  $self->{cfgbase} = $params->{cfgbase};
  $self->{logbasename} = "prescript";
  $self->{script} = $params->{script};
  $self->{scriptparams} = $params->{scriptparams};
  $self->{scriptstdin} = $params->{scriptstdin};
  $self->{scriptdelay} = $params->{scriptdelay};
  $self->default_options({ script => 0, protocol => 0, count => 1,
      smartscript => 0, supersmartscript => 0 });
  $self->{matchlines} = { OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [] };
  $self->{lastmsg} = { OK => "", WARNING => "", CRITICAL => "", UNKNOWN => "" };
  $self->{trace} = -e $self->{tracefile} ? 1 : 0;
  $self->refresh_options($params->{options});
  $self->{exitcode} = 0;
  $self->{macros}->{CL_LOGFILE} = $params->{cfgbase};
  $self->{macros}->{CL_TAG} = $self->{tag};
  $self->{macros}->{CL_SERVICESTATEID} = $ERRORS{OK};
  $self->{macros}->{CL_SERVICEOUTPUT} = "OK - starting up";
  $self->{macros}->{CL_PATTERN_NUMBER} = 0;
  return $self;
}

sub run {
  my $self = shift;
  $self->trace("call (%s) prescript %s",
      $self->{options}->{smartscript} ? "smart" : "dumb", $self->{script});
  my ($actionsuccess, $actionrc, $actionoutput) =
      $self->action($self->{script}, $self->{scriptparams},
      $self->{scriptstdin}, $self->{scriptdelay},
      $self->{options}->{smartscript}, $self->{privatestate});
  if (! $actionsuccess) {
    $self->{options}->{count} = 1;
    $self->{options}->{protocol} = 1;
    $self->addevent('WARNING',
        sprintf "cannot execute %s", $self->{script});
  } elsif ($self->{options}->{smartscript}) {
    if ($actionrc) {
      $actionoutput = "prescript" if ! $actionoutput;
      $self->addevent($actionrc, $actionoutput);
    }
  }
  $self->{exitcode} = $actionrc;
}


package Nagios::CheckLogfiles::Search::Postscript;

use strict;
use Exporter;
use File::Basename;
use vars qw(@ISA);

@ISA = qw(Nagios::CheckLogfiles::Search);

sub new {
  my $self = bless {}, shift;
  return $self->init(shift);
}

sub init {
  my $self = shift;
  my $params = shift;
  $self->{tag} = "postscript";
  $self->{scriptpath} = $params->{scriptpath};
  $self->{macros} = $params->{macros};
  $self->{tracefile} = $params->{tracefile};
  $self->{cfgbase} = $params->{cfgbase};
  $self->{logbasename} = "postscript";
  $self->{script} = $params->{script};
  $self->{scriptparams} = $params->{scriptparams};
  $self->{scriptstdin} = $params->{scriptstdin};
  $self->{scriptdelay} = $params->{scriptdelay};
  $self->{privatestate} = $params->{privatestate};
  $self->default_options({ script => 0, protocol => 0, count => 1,
      smartscript => 0, supersmartscript => 0 });
  $self->{matchlines} = { OK => [], WARNING => [], CRITICAL => [], UNKNOWN => [] };
  $self->{lastmsg} = { OK => "", WARNING => "", CRITICAL => "", UNKNOWN => "" };
  $self->{trace} = -e $self->{tracefile} ? 1 : 0;
  $self->refresh_options($params->{options});
  $self->{exitcode} = 0;
  $self->{macros}->{CL_LOGFILE} = $params->{cfgbase};
  $self->{macros}->{CL_TAG} = $self->{tag};
  $self->{macros}->{CL_SERVICESTATEID} = 0; # will be set in SUPER::run()
  $self->{macros}->{CL_SERVICEOUTPUT} = ""; # will be set in SUPER::run()
  $self->{macros}->{CL_PATTERN_NUMBER} = 0;
  return $self;
}

sub run {
  my $self = shift;
  $self->trace("call postscript %s", $self->{script});
  my ($actionsuccess, $actionrc, $actionoutput) =
      $self->action($self->{script}, $self->{scriptparams},
      $self->{scriptstdin}, $self->{scriptdelay},
      $self->{options}->{smartscript}, $self->{privatestate});
  if (! $actionsuccess) {
    $self->{options}->{count} = 1;
    $self->{options}->{protocol} = 1;
    $self->addevent('WARNING',
        sprintf "cannot execute %s", $self->{script});
    $actionrc = 2;
  } elsif ($self->{options}->{smartscript}) {
    if ($actionrc || $self->{options}->{supersmartscript}) {
      # strings containing 0 must be treated like a true value
      #$actionoutput = "postscript" if ! $actionoutput;
      $actionoutput = "postscript"
          unless $actionoutput || $actionoutput =~ /0[0\.]*/;
      $self->addevent($actionrc, $actionoutput);
    }
  }
  $self->{exitcode} = $actionrc;
}


package Nagios::CheckLogfiles::Search::Dummy;

use strict;
use Exporter;
use File::Basename;
use Time::Local;
use IO::File;
use vars qw(@ISA);

use constant OK => 0;
use constant WARNING => 1;
use constant CRITICAL => 2;
use constant UNKNOWN => 3;

@ISA = qw(Nagios::CheckLogfiles::Search);

sub new {
  my $self = bless {}, shift;
  return $self->init(shift);
}

sub init {
  my $self = shift;
  my $params = shift;
  $self->{logfile} = sprintf "%s/dummy.%s", $self->{seekfilesdir},
      $self->{tag};
  $self->SUPER::init($params);
}

sub prepare {
  my $self = shift;
  $self->{options}->{nologfilenocry} = 1;
}

sub loadstate {
  my $self = shift;
  $self->SUPER::loadstate();
}

sub savestate {
  my $self = shift;
}

sub analyze_situation {
  my $self = shift;
}

sub collectfiles {
  my $self = shift;
}

package Nagios::CheckLogfiles::Search::Errpt;

use strict;
use Exporter;
use File::Basename;
use Time::Local;
use IO::File;
use vars qw(@ISA);

use constant OK => 0;
use constant WARNING => 1;
use constant CRITICAL => 2;
use constant UNKNOWN => 3;

@ISA = qw(Nagios::CheckLogfiles::Search);

sub new {
  my $self = bless {}, shift;
  return $self->init(shift);
}

sub init {
  my $self = shift;
  my $params = shift;
  $self->{logfile} = sprintf "%s/errpt.%s", $self->{seekfilesdir},
      $self->{tag};
  $self->SUPER::init($params);
  $self->{clo} = {
  	path => $params->{errpt}->{path} ?
  	    $params->{errpt}->{path} : "errpt",
    errortype => $params->{errpt}->{errortype},
    errorclass => $params->{errpt}->{errorclass},
    errorlabel => $params->{errpt}->{errorlabel},
    errorresource => $params->{errpt}->{errorresource},
  };
  $self->addfilter(0, 'IDENTIFIER TIMESTAMP');
}

sub prepare {
  my $self = shift;
  $self->{options}->{nologfilenocry} = 1;
  # the last minute is the end time. in-progess minutes are not
  # interesting yet.
  my($sec, $min, $hour, $mday, $mon, $year) =
      #(localtime $self->{macros}->{CL_DATE_TIMESTAMP})[0, 1, 2, 3, 4, 5];
      # macro is not suitable for testing because it is not updated
      (localtime time)[0, 1, 2, 3, 4, 5];
  $self->{errpt}->{endtime} =
      timelocal(0, $min, $hour, $mday, $mon, $year) - 60;
}

sub loadstate {
  my $self = shift;
  $self->SUPER::loadstate();
  # always scan the whole output. thst's what starttime is for.
  $self->{laststate}->{logoffset} = 0;
  # if this is the very first run, look back 5 mintes in the past.
  $self->{errpt}->{starttime} = $self->{laststate}->{logtime} ?
      $self->{laststate}->{logtime} + 60 : $self->{errpt}->{endtime} - 300;
}

sub savestate {
  my $self = shift;
  foreach (keys %{$self->{laststate}}) {
    $self->{newstate}->{$_} = $self->{laststate}->{$_};
  }
  # remember the last minute scanned.
  $self->{newstate}->{logtime} = $self->{errpt}->{endtime};
  $self->SUPER::savestate();
}

sub analyze_situation {
  my $self = shift;
  if ($self->{errpt}->{starttime} <= $self->{errpt}->{endtime}) {
    $self->{logmodified} = 1;
  } else {
    # this happens if you call the plugin in too short intervals.
    $self->trace("%s not before %s",
        scalar localtime $self->{errpt}->{starttime},
        scalar localtime $self->{errpt}->{endtime});
  }
}

sub collectfiles {
  my $self = shift;
  my $fh = new IO::File;
  if ($self->{logmodified}) {
    my($sec, $min, $hour, $mday, $mon, $year) =
        (localtime $self->{errpt}->{starttime})[0, 1, 2, 3, 4, 5];
    $self->{errpt}->{ibmstarttime} = sprintf "%02d%02d%02d%02d%02d",
        $mon + 1, $mday, $hour, $min, substr($year + 1900, 2, 2);
    ($sec, $min, $hour, $mday, $mon, $year) =
        (localtime $self->{errpt}->{endtime})[0, 1, 2, 3, 4, 5];
    $self->{errpt}->{ibmendtime} = sprintf "%02d%02d%02d%02d%02d",
        $mon + 1, $mday, $hour, $min, substr($year + 1900, 2, 2);
    my $errpt = sprintf "%s -s %s -e %s %s %s %s %s|", $self->{clo}->{path},
        $self->{errpt}->{ibmstarttime}, $self->{errpt}->{ibmendtime},
        $self->{clo}->{errortype} ? '-T '.$self->{clo}->{errortype} : "",
        $self->{clo}->{errorclass} ? '-d '.$self->{clo}->{errorclass} : "",
        $self->{clo}->{errorlabel} ? '-J '.$self->{clo}->{errorlabel} : "",
        $self->{clo}->{errorresource} ? '-N '.$self->{clo}->{errorresource} : "";
    $self->trace("calling %s", $errpt);
    $self->trace("calling errpt -s (%s) -e (%s)",
        scalar localtime $self->{errpt}->{starttime},
        scalar localtime $self->{errpt}->{endtime});
    if ($fh->open($errpt)) {
      push(@{$self->{relevantfiles}},
        { filename => "errpt|",
          fh => $fh, seekable => 0,
          modtime => $self->{errpt}->{endtime},
          fingerprint => "0:0" });
    } else {
      $self->trace("cannot execute errpt");
      $self->addevent('UNKNOWN', "cannot execute errpt");
    }
  }
}

package Nagios::CheckLogfiles::Search::Ipmitool;

use strict;
use Exporter;
use File::Basename;
use Time::Local;
use IO::File;
use vars qw(@ISA);
require Digest::MD5; # qw(md5_base64);

use constant OK => 0;
use constant WARNING => 1;
use constant CRITICAL => 2;
use constant UNKNOWN => 3;

@ISA = qw(Nagios::CheckLogfiles::Search::Simple);

sub new {
  my $self = bless {}, shift;
  return $self->init(shift);
}

sub init {
  my $self = shift;
  my $params = shift;
  $self->{logfile} = sprintf "%s/ipmitool.%s", $self->{seekfilesdir},
      $self->{tag};
  $self->SUPER::init($params);
  $self->{clo} = {
      path => $params->{ipmitool}->{path} ?
      $params->{ipmitool}->{path} : "/usr/sbin/ipmitool",
      cache => exists $params->{ipmitool}->{elist} ? 1 : 0,
      listcmd => exists $params->{ipmitool}->{elist} ? "elist" : "list"
  };
}

sub prepare {
  my $self = shift;
  $self->{options}->{nologfilenocry} = 1;
  $self->{logfile} = sprintf "%s/ipmitool.sel.dump.%s",
      $self->system_tempdir(), $self->{tag};
  $self->{sdrcache} = sprintf "%s/ipmitool.sdr.cache",
      $self->system_tempdir();
  if ($self->{clo}->{cache} && (! -f $self->{sdrcache} ||
      ((time - ($self->{sdrcache})[9]) > 86400))) {
    $self->trace("creating/refreshing sdr cache %s", $self->{sdrcache});
    system($self->{clo}->{path}.' sdr dump '.$self->{sdrcache}.' >/dev/null 2>&1');
  }
  unlink $self->{logfile};
  my $ipmitool_sel_list = sprintf "%s %s sel %s 2>&1 |",
      $self->{clo}->{path},
      $self->{clo}->{cache} ? "-S $self->{sdrcache}" : "",
      $self->{clo}->{listcmd};
  my $ipmitool_fh = new IO::File;
  my $spool_fh = new IO::File;
  $self->trace("executing %s", $ipmitool_sel_list);
  if ($ipmitool_fh->open($ipmitool_sel_list)) {
    if ($spool_fh->open('>'.$self->{logfile})) {
      while (my $event = $ipmitool_fh->getline()) {
        chomp $event;
        next if $event =~ /SEL has no entries/;
        $event =~ s/\|/;/g;
        $spool_fh->printf("%s\n", $event);
      }
      $spool_fh->close();
    }
    $ipmitool_fh->close();
  }
  $self->trace("wrote spoolfile %s", $self->{logfile});
}

sub getfilefingerprint {
  my $self = shift;
  my $file = shift;
  if (-f $file) {
    my $magic;
    if (ref $file) {
      my $pos = $file->tell();
      $file->seek(0, 0);
      $magic = $file->getline() || "this_was_an_empty_file";
      $file->seek(0, $pos);
    } else {
      my $fh = new IO::File;
      $fh->open($file, "r");
      $magic = $fh->getline() || "this_was_an_empty_file";
      $fh->close();
    }
    $self->trace("magic: %s", $magic);
    return(Digest::MD5::md5_base64($magic));
  } else {
    return "0:0";
  }
}
package Nagios::CheckLogfiles::Search::Oraclealertlog;

use strict;
use Exporter;
use File::Basename;
use Time::Local;
use IO::File;
use vars qw(@ISA);

use constant OK => 0;
use constant WARNING => 1;
use constant CRITICAL => 2;
use constant UNKNOWN => 3;

@ISA = qw(Nagios::CheckLogfiles::Search);

sub new {
  my $self = bless {}, shift;
  return $self->init(shift);
}

sub init {
  my $self = shift;
  my $params = shift;
  $self->{oraalert}->{tns} = {
    connect => $params->{oraclealertlog}->{connect} ||
        $params->{oraclealertlog}->{sid},
    username => $params->{oraclealertlog}->{username},
    password => $params->{oraclealertlog}->{password},
  };
  $self->{logfile} = sprintf "%s/alertlog.%s.%s", $self->{seekfilesdir},
      $self->{tag},
      $self->{oraalert}->{tns}->{connect};
  $self->SUPER::init($params);
  $self->resolve_macros(\$self->{oraalert}->{tns}->{connect});
  $self->resolve_macros(\$self->{oraalert}->{tns}->{username});
  $self->resolve_macros(\$self->{oraalert}->{tns}->{password});
}

sub prepare {
  my $self = shift;
  $self->{options}->{nologfilenocry} = 1;
  # the last second is the end time. in-progess seconds are not
  # interesting yet.
  $self->{oraalert}->{highestfound} = 0;
}

sub loadstate {
  my $self = shift;
  $self->SUPER::loadstate();
  # always scan the whole output. thst's what starttime is for.
  $self->{laststate}->{logoffset} = 0;
  # if this is the very first run, look back 5 mintes in the past.
  # hopefully the clocks are synchronized
  $self->{laststate}->{logtime} = $self->{laststate}->{logtime} ?
      $self->{laststate}->{logtime} : time - 300;
}

sub savestate {
  my $self = shift;
    foreach (keys %{$self->{laststate}}) {
      $self->{newstate}->{$_} = $self->{laststate}->{$_};
    }
  # remember the last second scanned.
  $self->{newstate}->{logtime} = $self->{oraalert}->{highestfound} ?
      $self->{oraalert}->{highestfound} : $self->{laststate}->{logtime};
  $self->SUPER::savestate();
}

sub analyze_situation {
  my $self = shift;
  $self->trace("last scanned until %s",
      scalar localtime $self->{laststate}->{logtime});
  $self->{logmodified} = 1;
}

sub collectfiles {
  my $self = shift;
  my $fh = new IO::File;
  if ($self->{logmodified}) {
    # open database connection and select rows created
    # since $self->{laststate}->{logtime} and now (db now, not plugin now)
    my $linesread = 0;
    eval {
      require DBI;
      if (my $dbh = DBI->connect(
          sprintf("DBI:Oracle:%s", $self->{oraalert}->{tns}->{connect}),
          $self->{oraalert}->{tns}->{username},
          $self->{oraalert}->{tns}->{password},
          { RaiseError => 1, PrintError => 0 })) {
        $dbh->do(q{ ALTER SESSION SET NLS_NUMERIC_CHARACTERS=".," });
        # suchen bis zur letzten abgeschlossenen sekunde (inklusive)
        my $sql = q{
            SELECT alert_timestamp, alert_text FROM alert_log
            WHERE ROUND(alert_timestamp) > ? AND alert_date <= SYSDATE - 1/86400
            ORDER BY alert_timestamp
        };
        if (my $sth = $dbh->prepare($sql)) {
          $self->trace(sprintf "select events between %d and now (%s and sysdate())",
              $self->{laststate}->{logtime},
              scalar localtime $self->{laststate}->{logtime});
          $sth->execute($self->{laststate}->{logtime});
          if (my $fh = new IO::File($self->{logfile}, "w")) {
            while(my($alert_timestamp, $alert_text) = $sth->fetchrow_array()) {
              next if ! $alert_text; # es gibt auch leere Zeilen
              # bei ora-perl-conversion gibts manchmal 1234567890.999999999
              $alert_timestamp = int(0.5 + $alert_timestamp);
              $fh->printf("%s %s\n", scalar localtime $alert_timestamp, $alert_text);
              $self->{oraalert}->{highestfound} = $alert_timestamp;
              $linesread++;
            }
            $fh->close();
          }
          $sth->finish();
        }
        $dbh->disconnect();
      }
    };
    if ($@) {
      $self->trace(sprintf "database operation failed: %s", $@);
      $self->addevent('UNKNOWN', sprintf "database operation failed: %s", $@);
    }
    $self->trace(sprintf "read %d lines from database", $linesread);
    if ($linesread) {
      if (my $fh = new IO::File($self->{logfile}, "r")) {
        $self->trace(sprintf "reopen logfile");
        push(@{$self->{relevantfiles}},
          { filename => "eventlog|",
            fh => $fh, seekable => 0,
            modtime => time, # not relevant because already analyzed
            fingerprint => "0:0" });
      }
    }
  }
}


package main;

use strict;
use utf8;
use File::Basename;
use File::Find;
use Getopt::Long;

use constant OK => 0;
use constant WARNING => 1;
use constant CRITICAL => 2;
use constant UNKNOWN => 3;

Getopt::Long::Configure qw(no_ignore_case); # compatibility with old perls
use vars qw (%commandline);
my @cfgfiles = ();
my $needs_restart = 0;
my $enough_info = 0;

my $plugin_revision = '$Revision: 1.0 $ ';
my $progname = basename($0);

sub print_version {
  printf "%s v3.0\n", basename($0);
}

sub print_help {
  print <<EOTXT;
This Nagios Plugin comes with absolutely NO WARRANTY. You may use
it on your own risk!
Copyright by ConSol Software GmbH, Gerhard Lausser.

This plugin looks for patterns in logfiles, even in those who were rotated
since the last run of this plugin.

You can find the complete documentation at
http://www.consol.com/opensource/nagios/check-logfiles
or
http://www.consol.de/opensource/nagios/check-logfiles

Usage: check_logfiles [-t timeout] -f <configfile>

The configfile looks like this:

\$seekfilesdir = '/opt/nagios/var/tmp';
# where the state information will be saved.

\$protocolsdir = '/opt/nagios/var/tmp';
# where protocols with found patterns will be stored.

\$scriptpath = '/opt/nagios/var/tmp';
# where scripts will be searched for.

\$MACROS = \{ CL_DISK01 => "/dev/dsk/c0d1", CL_DISK02 => "/dev/dsk/c0d2" \};

\@searches = (
  {
    tag => 'temperature',
    logfile => '/var/adm/syslog/syslog.log',
    rotation => 'bmwhpux',
    criticalpatterns => ['OVERTEMP_EMERG', 'Power supply failed'],
    warningpatterns => ['OVERTEMP_CRIT', 'Corrected ECC Error'],
    options => 'script,protocol,nocount',
    script => 'sendnsca_cmd'
  },
  {
    tag => 'scsi',
    logfile => '/var/adm/messages',
    rotation => 'solaris',
    criticalpatterns => 'Sense Key: Not Ready',
    criticalexceptions => 'Sense Key: Not Ready /dev/testdisk',
    options => 'noprotocol'
  },
  {
    tag => 'logins',
    logfile => '/var/adm/messages',
    rotation => 'solaris',
    criticalpatterns => ['illegal key', 'read error.*\$CL_DISK01\$'],
    criticalthreshold => 4
    warningpatterns => ['read error.*\$CL_DISK02\$'],
  }
);

EOTXT
}

sub print_usage {
  print <<EOTXT;
Usage: check_logfiles [-t timeout] -f <configfile> [--searches=tag1,tag2,...]
       check_logfiles [-t timeout] --logfile=<logfile> --tag=<tag> --rotation=<rotation>
                      --criticalpattern=<regexp> --warningpattern=<regexp>

EOTXT
}

%commandline = ();
my @params = (
    "timeout|t=i",
    "version|V",
    "help|h",
    "debug|d",
    "verbose|v",
    #
    #
    #
    "environment|e=s%",
    "daemon:i",
    "report=s",
    "reset",
    #
    #
    #
    "install",
    "deinstall",
    "service=s",
    "username=s",
    "password=s",
    #
    # which searches
    #
    "config|f=s",
    "configdir|F=s",
    "searches=s",
    "selectedsearches=s",
    #
    # globals
    #
    "seekfilesdir=s",
    "protocolsdir=s",
    "protocolsretention=i",
    "macro=s%",
    #
    # search
    #
    "template=s",
    "tag=s",
    "logfile=s",
    "rotation=s",
    "tivolipattern=s",
    "criticalpattern=s",
    "criticalexception=s",
    "warningpattern=s",
    "warningexception=s",
    "okpattern=s",
    "type=s",
    "archivedir=s",
    #
    # search options
    #
    "noprotocol",
    "nocase",
    "nologfilenocry",
    "maxlength=i",
    "syslogserver",
    "syslogclient=s",
    "sticky:s",
    "noperfdata",
    "winwarncrit",
    "lookback=s",
    "context=i",
    "criticalthreshold=i",
    "warningthreshold=i",
    "encoding=s",
);
if (! GetOptions(\%commandline, @params)) {
  print_help();
  exit $ERRORS{UNKNOWN};
}

if (exists $commandline{version}) {
  print_version();
  exit UNKNOWN;
}

if (exists $commandline{help}) {
  print_help();
  exit UNKNOWN;
}

if (exists $commandline{config}) {
  $enough_info = 1;
} elsif (exists $commandline{configdir}) {
  $enough_info = 1;
} elsif (exists $commandline{logfile}) {
  $enough_info = 1;
} elsif (exists $commandline{type} && $commandline{type} =~ /^eventlog/) {
  $enough_info = 1;
} elsif (exists $commandline{deinstall}) {
  $commandline{type} = 'dummy';
  $enough_info = 1;
}
if (exists $commandline{lookback}) {
  if ($commandline{lookback} =~ /^(\d+)(s|m|h|d)$/) {
    if ($2 eq 's') {
      $commandline{lookback} = $1;
    } elsif ($2 eq 'm') {
      $commandline{lookback} = $1 * 60;
    } elsif ($2 eq 'h') {
      $commandline{lookback} = $1 * 60 * 60;
    } elsif ($2 eq 'd') {
      $commandline{lookback} = $1 * 60 * 60 *24;
    }
  } else {
    printf STDERR "illegal time interval (must be <number>[s|m|h|d]\n";
    print_usage();
    exit UNKNOWN;
  }
}

if (! $enough_info) {
  print_usage();
  exit UNKNOWN;
}

if (exists $commandline{daemon}) {
  my @newargv = ();
  foreach my $option (keys %commandline) {
    if (grep { /^$option/ && /=/ } @params) {
      push(@newargv, sprintf "--%s", $option);
      push(@newargv, sprintf "%s", $commandline{$option});
    } else {
      push(@newargv, sprintf "--%s", $option);
    }
  }
  $0 = 'check_logfiles '.join(' ', @newargv);
  if (! $commandline{daemon}) {
    $commandline{daemon} = 300;
  }
}
if (exists $commandline{environment}) {
  # if the desired environment variable values are different from
  # the environment of this running script, then a restart is necessary.
  # because setting $ENV does _not_ change the environment of the running script.
  foreach (keys %{$commandline{environment}}) {
    if ((! $ENV{$_}) || ($ENV{$_} ne $commandline{environment}->{$_})) {
      $needs_restart = 1;
      $ENV{$_} = $commandline{environment}->{$_};
    }
  }
}
if ($needs_restart) {
  my @newargv = ();
  foreach my $option (keys %commandline) {
    if (grep { /^$option/ && /=/ } @params) {
      if (ref ($commandline{$option}) eq "HASH") {
        foreach (keys %{$commandline{$option}}) {
          push(@newargv, sprintf "--%s", $option);
          push(@newargv, sprintf "%s=%s", $_, $commandline{$option}->{$_});
        }
      } else {
        push(@newargv, sprintf "--%s", $option);
        push(@newargv, sprintf "%s", $commandline{$option});
      }
    } else {
      push(@newargv, sprintf "--%s", $option);
    }
  }
  exec $0, @newargv;
  # this makes sure that even a SHLIB or LD_LIBRARY_PATH are set correctly
  # when the perl interpreter starts. Setting them during runtime does not
  # help loading e.g. libclntsh.so
  exit;
}

if (exists $commandline{configdir}) {
  sub eachFile {
    my $filename = $_;
    my $fullpath = $File::Find::name;
    #remember that File::Find changes your CWD,
    #so you can call open with just $_
    if ((-f $filename) && ($filename =~ /\.(cfg|conf)$/)) {
      push(@cfgfiles, $fullpath);
    }
  }
  find (\&eachFile, $commandline{configdir});
  @cfgfiles = sort { $a cmp $b } @cfgfiles;
}
if (exists $commandline{config}) {
  # -f is always first
  unshift(@cfgfiles, $commandline{config});
}
if (scalar(@cfgfiles) == 1) {
  $commandline{config} = $cfgfiles[0];
} elsif (scalar(@cfgfiles) > 1) {
  $commandline{config} = \@cfgfiles;
}
if (exists $commandline{searches}) {
  $commandline{selectedsearches} = $commandline{searches};
}
if (! exists $commandline{selectedsearches}) {
  $commandline{selectedsearches} = "";
}
if (exists $commandline{type}) {
  my ($type, $details) = split(":", $commandline{type});
}
if (exists $commandline{criticalpattern}) {
  $commandline{criticalpattern} = '.*' if
      $commandline{criticalpattern} eq 'match_them_all';
}
if (exists $commandline{warningpattern}) {
  $commandline{warningpattern} = '.*' if
      $commandline{warningpattern} eq 'match_them_all';
}
if (my $cl = Nagios::CheckLogfiles->new({
      cfgfile => $commandline{config} ? $commandline{config} : undef,
      searches => [
          map {
            if (exists $commandline{type}) {
              # "eventlog" or "eventlog:eventlog=application,source=cdrom"
              my ($type, $details) = split(":", $commandline{type});
              $_->{type} = $type;
              if ($details) {
                $_->{$type} = {};
                foreach my $detail (split(",", $details)) {
                  my ($key, $value) = split("=", $detail);
                  $_->{$type}->{$key} = $value;
                }
              }
            }
            $_;
          }
          map { # ausputzen
              foreach my $key (keys %{$_}) {
      	      delete $_->{$key} unless $_->{$key}}; $_;
          } ({
          tag =>
              $commandline{tag} ? $commandline{tag} : undef,
          logfile =>
              $commandline{logfile} ? $commandline{logfile} : undef,
          type =>
              $commandline{type} ? $commandline{type} : undef,
          rotation =>
              $commandline{rotation} ? $commandline{rotation} : undef,
          tivolipatterns =>
              $commandline{tivolipattern} ?
                  $commandline{tivolipattern} : undef,
          criticalpatterns =>
              $commandline{criticalpattern} ?
                  $commandline{criticalpattern} : undef,
          criticalexceptions =>
              $commandline{criticalexception} ?
                  $commandline{criticalexception} : undef,
          warningpatterns =>
              $commandline{warningpattern} ?
                  $commandline{warningpattern} : undef,
          warningexceptions =>
              $commandline{warningexception} ?
                  $commandline{warningexception} : undef,
          okpatterns =>
              $commandline{okpattern} ?
                  $commandline{okpattern} : undef,
          options => join(',', grep { $_ }
              $commandline{noprotocol} ? "noprotocol" : undef,
              $commandline{nocase} ? "nocase" : undef,
              $commandline{noperfdata} ? "noperfdata" : undef,
              $commandline{winwarncrit} ? "winwarncrit" : undef,
              $commandline{nologfilenocry} ? "nologfilenocry" : undef,
              $commandline{syslogserver} ? "syslogserver" : undef,
              $commandline{syslogclient} ? "syslogclient=".$commandline{syslogclient} : undef,
              $commandline{maxlength} ? "maxlength=".$commandline{maxlength} : undef,
              $commandline{lookback} ? "lookback=".$commandline{lookback} : undef,
              $commandline{context} ? "context=".$commandline{context} : undef,
              $commandline{criticalthreshold} ? "criticalthreshold=".$commandline{criticalthreshold} : undef,
              $commandline{warningthreshold} ? "warningthreshold=".$commandline{warningthreshold} : undef,
              $commandline{encoding} ? "encoding=".$commandline{encoding} : undef,
              defined $commandline{sticky} ? "sticky".($commandline{sticky} ? "=".$commandline{sticky} : "") : undef ),
          archivedir =>
              $commandline{archivedir} ?
                  $commandline{archivedir} : undef,
      })],
      selectedsearches => [split(/,/, $commandline{selectedsearches})],
      dynamictag => $commandline{tag} ? $commandline{tag} : undef,
      report => $commandline{report} ? $commandline{report} : undef,
      cmdlinemacros => $commandline{macro},
      seekfilesdir => $commandline{seekfilesdir} ? $commandline{seekfilesdir} : undef,
      protocolsdir => $commandline{protocolsdir} ? $commandline{protocolsdir} : undef,
      protocolsretention => $commandline{protocolsretention} ? $commandline{protocolsretention} : undef,
      reset => $commandline{reset} ? $commandline{reset} : undef,
  })) {
  $cl->{verbose} = $commandline{verbose} ? 1 : 0;
  $cl->{timeout} = $commandline{timeout} ? $commandline{timeout} : 60;
  if ($commandline{install}) {
    $cl->install_windows_service($commandline{service}, $commandline{config},
        $commandline{username}, $commandline{password});
  } elsif ($commandline{deinstall}) {
    $cl->deinstall_windows_service($commandline{service});
  } elsif ($commandline{daemon}) {
    $cl->run_as_daemon($commandline{daemon});
  } else {
    $cl->run();
  }
  printf "%s%s\n%s", $cl->{exitmessage},
      $cl->{perfdata} ? "|".$cl->{perfdata} : "",
      $cl->{long_exitmessage} ? $cl->{long_exitmessage}."\n" : "";
  exit $cl->{exitcode};
} else {
  printf "%s\n", $Nagios::CheckLogfiles::ExitMsg;
  exit $Nagios::CheckLogfiles::ExitCode;
}

#+end_example
** DONE #test vm: check_MEMORY and check_NETWORK: NRPE: Unable to read output
  CLOSED: [2014-10-06 Mon 15:39]
/usr/lib/nagios/plugins/check_linux_stats.pl -M -w 95,90 -c 100,95

/usr/lib/nagios/plugins/check_nrpe -H 127.0.0.1 -c check_MEMORY
#+begin_example
testenv:~# /usr/lib/nagios/plugins/check_nrpe -H 127.0.0.1 -c check_MEMORY
NRPE: Unable to read output
#+end_example
** DONE nagios check for fluig service
   CLOSED: [2014-10-06 Mon 16:48]
** DONE make all checks to be down case
   CLOSED: [2014-10-06 Mon 17:02]
** DONE Don't use 127.0.0.1; allowed_hosts
   CLOSED: [2014-10-06 Mon 17:02]
** DONE CHECK_NRPE: Error - Could not complete SSL handshake: edit nrpe.cfg file and the line allowed_hosts.
  CLOSED: [2014-10-25 Sat 09:14]
http://geekpeek.net/could-not-complete-ssl-handshake/
** nagios JMX monitor
https://www.zabbix.com/documentation/2.0/manual/config/items/itemtypes/jmx_monitoring
** DONE [#A] Track nagios rrd format                              :IMPORTANT:
  CLOSED: [2014-11-18 Tue 15:20]
('data', 'warn', 'crit', 'min')
#+BEGIN_EXAMPLE
    if status is False:
        print "CRITICAL: ADSYNC TEST Failed. Username is %s. It takes %s seconds |time=%s s;30;40;10" % \
                (username, elapsed_seconds, elapsed_seconds)
        sys.exit(EXIT_ERROR)

    ret = EXIT_ERROR
    if seconds < WARNING_THRESHOLD:
        print "OK: ADSYNC TEST is GOOD . Username is %s. It takes %s seconds |time=%s s;30;40;10" % \
                (username, elapsed_seconds, elapsed_seconds)
        ret = EXIT_OK
    elif seconds >= WARNING_THRESHOLD and seconds < CRITICAL_THRESHOLD:
        print "WARNING: ADSYNC TEST is slow. Username is %s. It takes %s seconds |time=%s s;30;40;10" % \
                (username, elapsed_seconds, elapsed_seconds)
        ret = EXIT_WARNING
    elif seconds >= CRITICAL_THRESHOLD:
        print "CRITICAL: ADSYNC TEST is timeout. Username is %s. It takes %s seconds |time=%s s;30;40;10" % \
                (username, elapsed_seconds, elapsed_seconds)
        ret = EXIT_ERROR
    else:
        print "UNKNOWN: performing ADSYNC TEST failed. Username is %s. It takes %s seconds |time=%s s;30;40;10" % \
                (username, elapsed_seconds, elapsed_seconds)
        ret = EXIT_ERROR
    sys.exit(ret)


#+END_EXAMPLE
** TODO [#A] why 172.20.16.26/check_custom_login___time.rrd not updated any more: hostname is changed from 172.20.16.26 to fluig-id-app-03
root@fluig-id-cdn-01:/usr/local/nagiosgraph/var/rrd# ls -lth ./172.20.16.26/check_custom_login___time.rrd
<ls -lth ./172.20.16.26/check_custom_login___time.rrd
-rw-rw-r-- 1 nagios nagios 93K Feb 24 03:14 ./172.20.16.26/check_custom_login___time.rrd
root@fluig-id-cdn-01:/usr/local/nagiosgraph/var/rrd# date
date
Fri Feb 27 16:39:18 GMT 2015
** DONE [#A] why nagios rrdfile not generated: the output doesn't show the right output :IMPORTANT:
   CLOSED: [2014-12-16 Tue 12:45]
http://172.20.16.13/nagiosgraph/cgi-bin/show.cgi?host=172.20.16.26&service=check_custom_login
ls -lth /usr/local/nagiosgraph/var/rrd/172.20.16.26 | grep -i cust
*** right
#+BEGIN_EXAMPLE
root@app-03:~# /usr/lib/nagios/plugins/check_custom_login.sh
/usr/lib/nagios/plugins/check_custom_login.sh
OK: SUCCESSFULLY FOUND CUSTOM LOGIN PAGE AND LOGGED IN | time=33 seconds
#+END_EXAMPLE
*** error
#+BEGIN_EXAMPLE
root@app-03:~# /usr/lib/nagios/plugins/check_custom_login.sh
/usr/lib/nagios/plugins/check_custom_login.sh
OK: SUCCESSFULLY FOUND CUSTOM LOGIN PAGE AND LOGGED IN | 33 seconds
#+END_EXAMPLE
** DONE nagios create a new user
  CLOSED: [2014-12-22 Mon 10:18]
http://soeasytomakeitwork.wordpress.com/2012/07/11/add-an-user-access-to-nagios-web-interface/

# Note it will overwrite existing ones
htpasswd -c /etc/nagios3/htpasswd.users readonly

/etc/nagios3/htpasswd.users
htpasswd2 -c /usr/local/nagios/etc/htpasswd.users newusername
service apache2 reload

Need to change cgi.cfg, in order to grant privilege
http://cyruslab.net/2012/10/19/nagios-it-appears-as-though-you-do-not-have-permission-to-view-information-for-any-of-the-hosts-you-requested/
** DONE nagios complains about login
  CLOSED: [2014-12-19 Fri 00:32]
/usr/lib/nagios/plugins/check_custom_login.sh
/usr/lib/nagios/plugins/check_custom_login.sh

export CLASSPATH=.:$CLASSPATH:/opt/selenium-server-standalone-2.38.0.jar
javac ValidateCustomLoginPage.java && java ValidateCustomLoginPage
./check_custom_login.sh
** DONE nagios fd checks doesn't look good: nagios user can't run lsof
   CLOSED: [2014-12-22 Mon 10:58]
** DONE nagios check_search_log timeout: too many log message generated
   CLOSED: [2014-12-22 Mon 10:58]
** DONE nagios avoid tons of same exception message
  CLOSED: [2015-01-01 Thu 08:50]
http://labs.consol.de/nagios/check_logfiles/
http://labs.consol.de/lang/en/nagios/check_logfiles/

/usr/lib/nagios/plugins/check_nrpe -H 127.0.0.1 -c check_cloudpass_log

echo "error ok this" >> /data/fluigidentity-logs/cloudpass_logs/server.log

    okpatterns => [
        'error ok'
        ],


okpattern
** DONE app02, check_tomcat_log still have exceptions: symbol link for logfiles
  CLOSED: [2015-01-01 Thu 10:28]
echo "saml2.SPInitPostController Exception processing SAML: Exception extracting SAML message from the request: This message decoder only supports the HTTP POST method" >> /var/log/tomcat7/cloudpass.log && /usr/lib/nagios/plugins/check_logfiles -f /etc/nagios/log_cfg/tomcat_log.cfg

/etc/init.d/nagios-nrpe-server restart

echo "saml2.SPInitPostController Exception processing SAML: Exception extracting SAML message from the request: This message decoder only supports the HTTP POST method" >>  /var/log/tomcat7/catalina.out

cat /var/log/tomcat7/cloudpass.log

echo "saml2.SPInitPostController Exception processing SAML: Exception extracting SAML message from the request: This message decoder only supports the HTTP POST method" >> /var/log/tomcat7/cloudpass.log

/usr/lib/nagios/plugins/check_logfiles -f /etc/nagios/log_cfg/tomcat_log.cfg

echo "saml2.SPInitPostController Exception processing SAML: Exception extracting SAML message from the request: This message decoder only supports the HTTP POST method" >> /var/log/tomcat7/cloudpass.log && /usr/lib/nagios/plugins/check_logfiles -f /etc/nagios/log_cfg/tomcat_log.cfg

/usr/lib/nagios/plugins/check_nrpe -H 127.0.0.1 -c check_tomcat_log

root@fluig-id-cdn-01:~# /usr/lib/nagios/plugins/check_nrpe -H fluig-id-app-02 -c check_tomcat_log
<r/lib/nagios/plugins/check_nrpe -H fluig-id-app-02 -c check_tomcat_log
CRITICAL - (18 errors, 12 warnings) - 2015-01-01 14:05:50,990 [ajp-bio-8009-exec-3481] ERROR saml2.SPInitPostController  - Exception processing SAML: Exception extracting SAML message from the request: This message decoder only supports the HTTP POST method ...|default_lines=168 default_warnings=0 default_criticals=0 default_unknowns=0 default_lines=159 default_warnings=6 default_criticals=6 default_unknowns=0 default_lines=168 default_warnings=0 default_criticals=6 default_unknowns=0 default_lines=159 default_warnings=6 default_criticals=6 default_unknowns=0

root@app2:/etc/nagios/log_cfg# grep 'Exception processing SAML: Exception extracting SAML message from the request: This message decoder only supports the HTTP POST method' tomcat_log.cfg
<coder only supports the HTTP POST method' tomcat_log.cfg
        'saml2.SPInitPostController.*Exception processing SAML: Exception extracting SAML message from the request: This message decoder only supports the HTTP POST method'
root@app2:/etc/nagios/log_cfg# tail -n 10000 /var/log/tomcat7/catalina.out  | grep 'Exception processing SAML: Exception extracting SAML message from the request: This message decoder only supports the HTTP POST method' | tail
<uest: This message decoder only supports the HTTP POST method' | tail
saml2.SPInitPostController Exception processing SAML: Exception extracting SAML message from the request: This message decoder only supports the HTTP POST method
saml2.SPInitPostController Exception processing SAML: Exception extracting SAML message from the request: This message decoder only supports the HTTP POST method
saml2.SPInitPostController Exception processing SAML: Exception extracting SAML message from the request: This message decoder only supports the HTTP POST method
*** TODO ok
# Configuration file for check_logfiles command
#

# where the state information will be saved.
$seekfilesdir = '/var/tmp';

# where protocols with found patterns will be stored.
$protocolsdir = '/var/tmp';

# where scripts will be searched for.
#$scriptpath = '/var/log/tomcat7';

@searches = (
  {
    logfile => '/var/log/tomcat7/cloudpass.log',

    criticalpatterns => [
	'exception',
        'Exception',
	],

    warningpatterns => [
	'error',
        'Error',
        'ERROR',
	],
    okpatterns => [
        '.*This message decoder only supports the HTTP POST.*',
        ],

    options => 'noprotocol,count,nologfilenocry',
  }
);
*** error
# Configuration file for check_logfiles command
#

# where the state information will be saved.
$seekfilesdir = '/var/tmp';

# where protocols with found patterns will be stored.
$protocolsdir = '/var/tmp';

# where scripts will be searched for.
#$scriptpath = '/var/log/tomcat7';

@searches = (
  {
    logfile => '/var/log/tomcat7/catalina.out',

    criticalpatterns => [
	'exception',
        'Exception',
	],

    warningpatterns => [
	'error',
        'Error',
        'ERROR',
	],

    okpatterns => [
        'saml2.SPInitPostController.*Exception processing SAML: Exception extracting SAML message from the request: This message decoder only supports the HTTP POST method'
        ],

    options => 'noprotocol,count,nologfilenocry',
  },
  {
    logfile => '/var/log/tomcat7/cloudpass.log',

    criticalpatterns => [
	'exception',
        'Exception',
	],

    warningpatterns => [
	'error',
        'Error',
        'ERROR',
	],
    okpatterns => [
        'saml2.SPInitPostController.*Exception processing SAML: Exception extracting SAML message from the request: This message decoder only supports the HTTP POST method'
        ],

    options => 'noprotocol,count,nologfilenocry',
  },
  {
    logfile => '/var/lib/tomcat7/logs/catalina.out',

    criticalpatterns => [
	'exception',
        'Exception',
	],

    warningpatterns => [
	'error',
        'Error',
        'ERROR',
	],

    options => 'noprotocol,count,nologfilenocry',
  },
  {
    logfile => '/var/lib/tomcat7/logs/cloudpass.log',

    criticalpatterns => [
	'exception',
        'Exception',
	],

    warningpatterns => [
	'error',
        'Error',
        'ERROR',
	],

    options => 'noprotocol,count,nologfilenocry',
  },
);
** DONE [#B] NRPE: Unable to read output, but nagios doesn't detect error : script don't return error
  CLOSED: [2015-02-03 Tue 18:54]
172.20.16.26

check_custom_login

check_nrpe3!check_custom_login

/usr/lib/nagios/plugins/check_nrpe -H 104.131.134.190 -c check_neo4j
** DONE nagios check_logfiles
  CLOSED: [2015-02-23 Mon 15:13]
https://wiki.icinga.org/display/howtos/check_logfiles

# cd /usr/lib/nagios/plugins
# wget http://labs.consol.de/wp-content/uploads/2012/02/check_logfiles-3.4.7.1.tar.gz ; tar xzf check_logfiles-3.4.7.1.tar.gz; cd check_logfiles-3.4.7.1; ./configure ; make ; cp plugins-scripts/check_logfiles ../; cd ..; chmod +x check_logfiles

/usr/lib/nagios/plugins/check_logfiles -f /etc/nagios/log_cfg/apache_log.cfg

./check_logfiles -f /etc/nagios/log_cfg/apache_log.cfg
#+BEGIN_EXAMPLE
nagios@1a4cb38fa5d7:/root$ ls -lth /var/log/apache2/error.log
ls -lth /var/log/apache2/error.log
-rwxrwxrwx 1 root adm 1020 Feb 23 15:15 /var/log/apache2/error.log
nagios@1a4cb38fa5d7:/root$ grep check_apache_log /etc/nagios/nrpe.d/ -r
grep check_apache_log /etc/nagios/nrpe.d/ -r
/etc/nagios/nrpe.d/check_logfile.cfg:command[check_apache_log]=/usr/lib/nagios/plugins/check_logfiles -f /etc/nagios/log_cfg/apache_log.cfg
nagios@1a4cb38fa5d7:/root$ /usr/lib/nagios/plugins/check_logfiles -f /etc/nagios/log_cfg/apache_log.cfg
</usr/lib/nagios/plugins/check_logfiles -f /etc/nagios/log_cfg/apache_log.cfg
syntax error at /usr/lib/nagios/plugins/check_logfiles line 961, near "$level qw(CRITICAL WARNING UNKNOWN OK)"
Global symbol "$level" requires explicit package name at /usr/lib/nagios/plugins/check_logfiles line 962.
Global symbol "$level" requires explicit package name at /usr/lib/nagios/plugins/check_logfiles line 963.
Global symbol "$self" requires explicit package name at /usr/lib/nagios/plugins/check_logfiles line 963.
Global symbol "$level" requires explicit package name at /usr/lib/nagios/plugins/check_logfiles line 963.
Global symbol "$self" requires explicit package name at /usr/lib/nagios/plugins/check_logfiles line 964.
Global symbol "$level" requires explicit package name at /usr/lib/nagios/plugins/check_logfiles line 964.
Global symbol "$self" requires explicit package name at /usr/lib/nagios/plugins/check_logfiles line 964.
Global symbol "$self" requires explicit package name at /usr/lib/nagios/plugins/check_logfiles line 965.
Global symbol "$level" requires explicit package name at /usr/lib/nagios/plugins/check_logfiles line 965.
Global symbol "$self" requires explicit package name at /usr/lib/nagios/plugins/check_logfiles line 966.
Global symbol "$level" requires explicit package name at /usr/lib/nagios/plugins/check_logfiles line 966.
Global symbol "$self" requires explicit package name at /usr/lib/nagios/plugins/check_logfiles line 969.
syntax error at /usr/lib/nagios/plugins/check_logfiles line 971, near "}"
/usr/lib/nagios/plugins/check_logfiles has too many errors.
#+END_EXAMPLE
** TODO nagios check_mk
https://mathias-kettner.de/check_mk.html
http://grass51.blog.51cto.com/4356355/994819
其优点能够:
- 自动检测主机上的监控项目
- 并且在监控端的CPU使用率也显著减少
** TODO nagios Check_MK
I denny

i tried to find in the history also but still remains unknown the logs.

Also o would like to inform that we are migrating Nagios to Check_MK

https://dcmon.totvs.com.br/
user:fluig-identity
pass:totvs@123

WE add the network latency in this graphs and software latency as well.


Regards,
Lucas Schiochet
** DONE nagios check: http curl check
  CLOSED: [2015-05-16 Sat 07:16]
/usr/lib/nagios/plugins/check_http -H localhost --ssl -u http://127.0.0.1:8443/mdm/mdm-ui -p 8443
/usr/lib/nagios/plugins/check_http -H localhost -u http://localhost/healthcheck -p 18081 -w 2 -c 4
** #  --8<-------------------------- separator ------------------------>8--
** TODO nagios check service status running: service apache2 status
http://serverfault.com/questions/387859/generic-nagios-plugin-to-check-if-a-specific-process-service-is-running

https://github.com/jonschipp/nagios-plugins/blob/master/check_service.sh
https://exchange.nagios.org/directory/Plugins/Network-and-Systems-Management/Unix-2FLinux-Check-Service-Status/details
https://exchange.nagios.org/directory/Plugins/Operating-Systems/Linux/Check--2Fetc-2Finit-2Ed-2F-24script_name-status/details
** TODO [#A] Nagios define name for ip                            :IMPORTANT:
** TODO [#A] nagiosgraph add more comment to better describe the graph :IMPORTANT:
http://172.20.16.13/nagiosgraph/cgi-bin/show.cgi?host=customerfi-id-keystore&service=check_disk_rootfs
http://10.165.4.198/nagiosgraph/cgi-bin/show.cgi?host=127.0.0.1&service=check_load
** DONE nagios: command run successfully with root user, however nagios user fails
  CLOSED: [2015-06-28 Sun 21:58]
su nagios

bash -xe /usr/local/opendj/bin/status --trustAll -n -j /opt/authright/config/opendj_passwd

#+BEGIN_EXAMPLE
root@4e69aee94fd5:/etc/nagios/nrpe.d# /usr/lib/nagios/plugins/check_nrpe -H 172.17.0.4 -c check_opendj_status
</plugins/check_nrpe -H 172.17.0.4 -c check_opendj_status
Unable to connect to the server at "4e69aee94fd5" on port 4444
root@4e69aee94fd5:/etc/nagios/nrpe.d# /usr/local/opendj/bin/status --trustAll -n -j /opt/authright/config/opendj_passwd
<dj/bin/status --trustAll -n -j /opt/authright/config/opendj_passwd

          --- Server Status ---
Server Run Status:        Started
Open Connections:         1

          --- Server Details ---
Host Name:                4e69aee94fd5
Administrative Users:     cn=Directory Manager
Installation Path:        /usr/local/opendj-1
Version:                  OpenDJ 3.0.0-SNAPSHOT
Java Version:             1.8.0_40
Administration Connector: Port 10004 (LDAPS)

          --- Connection Handlers ---
Address:Port : Protocol : State
-------------:----------:---------
--           : LDIF     : Disabled
0.0.0.0:161  : SNMP     : Disabled
0.0.0.0:389  : LDAP     : Enabled
0.0.0.0:636  : LDAPS    : Disabled
0.0.0.0:1689 : JMX      : Disabled
0.0.0.0:8080 : HTTP     : Disabled

          --- Data Sources ---
-No LDAP Databases Found-
#+END_EXAMPLE
** DONE nagios send critical and warning alerts differently
  CLOSED: [2016-12-20 Tue 21:08]
https://support.nagios.com/forum/viewtopic.php?f=6&t=11699
https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/3/en/objectdefinitions.html

service_notification_options:	This directive is used to define the service states for which notifications can be sent out to this contact. Valid options are a combination of one or more of the following: w = notify on WARNING service states, u = notify on UNKNOWN service states, c = notify on CRITICAL service states, r = notify on service recoveries (OK states), and f = notify when the service starts and stops flapping. If you specify n (none) as an option, the contact will not receive any type of service notifications.
** DONE nagios check alerts by host: http://45.55.6.34:8085/cgi-bin/nagios3/status.cgi?host=prod-cb-4
   CLOSED: [2017-01-10 Tue 19:01]
** DONE nagiosgraph show multiple attributes: print "OK: mean process time is %s ms!|max_ms=%s min_ms=%s mean_ms=%s"
   CLOSED: [2017-05-10 Wed 16:48]
** #  --8<-------------------------- separator ------------------------>8-- :noexport:
** TODO bug: nagios3 is enabled for all nodes
root@bematech-do-es-14:~# ps -ef | grep nag
root       150     2  0 22:34 ?        00:00:00 [charger_manager]
nagios   27227     1  0 23:19 ?        00:00:00 /usr/sbin/nagios3 -d /etc/nagios3/nagios.cfg
nagios   28746     1  0 23:19 ?        00:00:00 /usr/sbin/nrpe -c /etc/nagios/nrpe.cfg -d
root     29738  1856  0 23:27 pts/1    00:00:00 grep --color=auto nag
** TODO why nagios didn't detect high load
Bruno Volpato
[4:56 PM]
never saw this like app3


[4:56]
top - 21:56:20 up 105 days,  6:04,  1 user,  load average: 7355.67, 6067.12, 3155.50


[4:56]
root@bematech-do-app-3:/opt/mdm/logs# uptime
 21:56:36 up 105 days,  6:04,  1 user,  load average: 7355.82, 6130.27, 3222.83


[4:56]
what load is this?


[4:56]
@denny.zhang


[4:57]
apport is using it


Denny Zhang
[4:57 PM]
That's crazy


[4:57]
Let me check
** TODO why nagios disk: app-5 doesn't detect this issue
Denny Zhang
[11:49 AM]
@kungwang

In app05. Disk usage of /data2 is 100%
```root@bematech-do-app-5:/# df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            7.9G   12K  7.9G   1% /dev
tmpfs           1.6G  396K  1.6G   1% /run
/dev/vda1       158G   68G   84G  45% /
none            4.0K     0  4.0K   0% /sys/fs/cgroup
none            5.0M     0  5.0M   0% /run/lock
none            7.9G     0  7.9G   0% /run/shm
none            100M     0  100M   0% /run/user
/dev/sda        493G  466G  1.2G 100% /data2
```
** TODO nagios check: why mdm-da1c1280ac9b11e68e250401f8d88501 not detected?
** TODO github repo: list all nagios alerts
** TODO [#A] Why no nagios disk alerts: prod-es-do-01              :IMPORTANT:
root@bematech-do-es-1:/tmp# df -h
Filesystem      Size  Used Avail Use% Mounted on
udev             16G  4.0K   16G   1% /dev
tmpfs           3.2G  420K  3.2G   1% /run
/dev/vda1       315G  270G   33G  90% /
none            4.0K     0  4.0K   0% /sys/fs/cgroup
none            5.0M     0  5.0M   0% /run/lock
none             16G     0   16G   0% /run/shm
none            100M     0  100M   0% /run/user
/dev/sda        493G  7.8G  460G   2% /mnt/es-extra-volume
root@bematech-do-es-1:/tmp# cd /etc/nagios/nrpe.d/
root@bematech-do-es-1:/etc/nagios/nrpe.d# grep check_disk ./ -r
./common_nrpe.cfg:command[check_disk_rootfs]=/usr/lib/nagios/plugins/check_linux_stats.pl -D -w 15 -c 10 -u % -p /
./common_nrpe.cfg:command[diskspace]=/usr/lib/nagios/plugins/check_diskspace.py
./common_nrpe.cfg:command[check_disk]=/usr/lib/nagios/plugins/check_linux_stats.pl -D -w 10 -c 5
root@bematech-do-es-1:/etc/nagios/nrpe.d# /usr/lib/nagios/plugins/check_linux_stats.pl -D -w 15 -c 10 -u % -p /
DISK WARNING used :  / 10.26% free | /=282655508KB
root@bematech-do-es-1:/etc/nagios/nrpe.d# /usr/lib/nagios/plugins/check_linux_stats.pl -D -w 15 -c 10 -u % -p /
DISK WARNING used :  / 10.26% free | /=282655520KB
root@bematech-do-es-1:/etc/nagios/nrpe.d#
** TODO In DO CB rebalancing, cpu load is high, but why no nagios alerts?
** TODO nagios history of memory and cpu
** TODO nagios check alerts by group
/Users/mac/Desktop/nagios_check_by_group.png
** TODO [#A] nagios check hook, when a given check fails: run jstack, it too many threads
** CANCELED nagios check: remove localhost, while keep those useful checks
  CLOSED: [2014-10-06 Mon 15:58]
/etc/nagios3/conf.d/localhost_nagios2.cfg

/sshx:root@107.170.211.216:/etc/nagios/objects/localhost.cfg

        service_description             Disk Space
        check_command                   check_all_disks!20%!10%
** CANCELED ubuntu nagios: Error: Could not stat() command file
  CLOSED: [2014-10-07 Tue 13:59]
ls -lth /var/lib/nagios3/rw

sudo /etc/init.d/nagios3 stop
sudo dpkg-statoverride --update --add nagios www-data 2710 /var/lib/nagios3/rw
sudo dpkg-statoverride --update --add nagios nagios 751 /var/lib/nagios3
sudo /etc/init.d/nagios3 start

http://sharadchhetri.com/2013/06/05/error-could-not-stat-command-file-varlibnagios3rwnagios-cmd/
http://www.krenger.ch/blog/nagios-error-could-not-stat-command-file/
http://www.asim.pk/2012/08/12/error-could-not-stat-command-file-var-lib-nagios3-rw-nagios-cmd/
* [#A] Zabbix: Open Source Monitoring Solution           :noexport:IMPORTANT:
http://www.zabbix.com/documentation/2.0/manual/introduction\\

http://ecae-102.dev:18000/zabbix/\\

http://www.zabbix.com/documentation/2.0/manual/config/items/itemtypes/external?s[]=external&s[]=script\\

- 对于host需要自己加template, 同时注意agent的port是否正确　
- 查看Latest data, 看看有没最新信息被采集出来了
- Zabbix configuration data require a fixed amount of disk space and do not grow much.
** basic use
#+BEGIN_EXAMPLE
http://www.zabbix.com/documentation/2.0/manual/introduction\\
#+begin_example
Zabbix is an enterprise-class open source distributed monitoring
solution.

Zabbix is software that monitors numerous parameters of a network and
the health and integrity of servers. Zabbix uses a flexible
notification mechanism that allows users to configure e-mail based
alerts for virtually any event. This allows a fast reaction to server
problems. Zabbix offers excellent reporting and data visualisation
features based on the stored data. This makes Zabbix ideal for
capacity planning.

Zabbix supports both polling and trapping. All Zabbix reports and
statistics, as well as configuration parameters, are accessed through
a web-based front end. A web-based front end ensures that the status
of your network and the health of your servers can be assessed from
any location. Properly configured, Zabbix can play an important role
in monitoring IT infrastructure. This is equally true for small
organisations with a few servers and for large companies with a
multitude of servers.
#+end_example
#+END_EXAMPLE
** Zabbix features
http://www.zabbix.com/documentation/2.0/manual/introduction\\
#+begin_example
Zabbix is a highly integrated network monitoring solution, offering a
multiplicity of features in a single package.

Data gathering

    availability and performance checks
    support for SNMP (both trapping and polling), IPMI, JMX monitoring
    custom checks
    gathering desired data at custom intervals
    performed by server/proxy and by agents

Flexible threshold definitions

    you can define very flexible problem thresholds, called triggers,
    referencing values from the back-end database

Highly configurable alerting

    sending notifications can be customized for the escalation
    schedule, recipient, media type notifications can be made
    meaningful and helpful using macro variables automatic actions
    include remote commands

Real-time graphing

    monitored items are immediately graphed using the built-in
    graphing functionality

Web monitoring capabilities

    Zabbix can follow a path of simulated mouse clicks on a web site
    and check for functionality and response time

Extensive visualisation options

    ability to create custom graphs that can combine multiple items into a single view
    network maps
    custom screens and slide shows for a dashboard-style overview
    reports
    high-level (business) view of monitored resources

Historical data storage

    data stored in a database
    configurable history
    built-in housekeeping procedure

Easy configuration

    add monitored devices as hosts
    hosts are picked up for monitoring, once in the database
    apply templates to monitored devices

Use of templates

    grouping checks in templates
    templates can inherit other templates

Network discovery

    automatic discovery of network devices
    agent auto registration
    discovery of file systems, network interfaces and SNMP OIDs

Fast web interface

    a web-based front-end in PHP
    accessible from anywhere
    you can click your way through
    audit log

Zabbix API

    Zabbix API provides programmable interface to Zabbix for mass
    manipulations, 3rd party software integration and other purposes.

Permissions system

    secure user authentication
    certain users can be limited to certain views

Full featured and easily extensible agent

    deployed on monitoring targets
    can be deployed on both Linux and Windows

Binary daemons

    written in C, for performance and small memory footprint
    easily portable

Ready for complex environments

    remote monitoring made easy by using a Zabbix proxy
#+end_example
** Zabbix concepts
   http://www.zabbix.com/documentation/2.0/manual/concepts\\
** TODO [#A] Install and try zabbix
   http://www.zabbix.com/wiki/howto/install/ubuntu/ubuntuinstall\\
   http://www.zabbix.com/documentation/2.0/manual/installation/install#from_distribution_packages\\
** TODO zabbix的trapping是什么功能?
** useful link
 http://www.zabbix.com/\\
** TODO configure: error: Not found NET-SNMP library
   You need both net-snmp and net-snmp-devel installed.

   sudo apt-get install build-essential mysql-server
   libmysqlclient15-dev php5 php5-gd php5-mysql snmp libsnmp-dev snmpd
   libcurl4-openssl-dev fping

   http://www.zabbix.com/forum/showthread.php?t=23941\\

http://www.zabbix.com/wiki/howto/install/ubuntu/ubuntuinstall\\
** DONE [#A] 在hudson中部署zabbix                        :IMPORTANT:noexport:
   CLOSED: [2012-06-12 Tue 17:03]
*** TODO [#C] zabbix-server无法自动发现client agent
*** DONE zabbix-server需要装: php-bcmath php-gd
    CLOSED: [2012-06-06 Wed 18:18]
#+begin_example
2012/06/06 17:59:24 [error] 27357#0: *3 FastCGI sent in stderr: "PHP Notice:  openlog don't init in Unknown on line 0
PHP Fatal error:  Call to undefined function bcscale() in /usr/share/zabbix/include/defines.inc.php on line 797" while reading response header from upstream, client: 192.168.75.111, server: ecae-13.demo, request: "HEAD /zabbix/ HTTP/1.1", upstream: "fastcgi://127.0.0.1:9000", host: "192.168.75.111:18000"
#+end_example
**** useful link
http://www.zabbix.com/forum/showthread.php?t=23735\\
*** DONE zabbix-server的php配置问题
    CLOSED: [2012-06-06 Wed 18:31]
/etc/php.ini

post_max_size = 16M
max_input_time = 300

http://drupal.org/node/109994\\
#+begin_example
PHP post max size	8M	16M is minimum size of PHP post
PHP max input time	60	300 sec is a minimal limitation on input parse time for PHP scripts
#+end_example
*** DONE zabbix-server中特别的configuration: /usr/local/nginx/conf/vhosts/monitor.conf
    CLOSED: [2012-06-06 Wed 18:43]
#+begin_example
# server {
#     listen       18000;
#     server_name _;
#     root /dev/null;
# }
#+end_example
** DONE zabbix, nagios与cacti的区别
   CLOSED: [2012-06-16 六 03:24]
   http://kkovacs.eu/zabbix-vs-nagios\\
   http://www.innovatedigital.com/node/553\\
   http://bbs.linuxtone.org/thread-9068-1-1.html\\
   http://www.linuxquestions.org/questions/linux-enterprise-47/nagios-vs-zabbix-216790/\\
** mail: zabbix                                                    :noexport:
#+begin_example
From: 吕志浩 <lvzhihao@shopex.cn>
Subject: zabbix
To: 张巍 <zhangwei@shopex.cn>
CC: 王磊 <flaboy@shopex.cn>
Date: Fri, 27 Apr 2012 14:49:34 +0800

http://ecae-102.dev:18000/zabbix/\\

ecae

welovecae

Your best partner

吕志浩

Email: lvzhihao@shopex.cn

ECAE: http://www.ec-ae.com
#+end_example
** sample files of zabbix
*** zabbix template
#+begin_example
<?xml version="1.0" encoding="UTF-8"?>
<zabbix_export>
    <version>2.0</version>
    <date>2012-07-14T17:01:50Z</date>
    <groups>
        <group>
            <name>mygroup</name>
        </group>
    </groups>
    <templates>
        <template>
            <template>tempate1</template>
            <name>tempate1</name>
            <groups>
                <group>
                    <name>mygroup</name>
                </group>
            </groups>
            <applications/>
            <items>
                <item>
                    <name>newitem1</name>
                    <type>10</type>
                    <snmp_community></snmp_community>
                    <multiplier>0</multiplier>
                    <snmp_oid></snmp_oid>
                    <key>sanitycheck.sh</key>
                    <delay>30</delay>
                    <history>90</history>
                    <trends>365</trends>
                    <status>0</status>
                    <value_type>3</value_type>
                    <allowed_hosts></allowed_hosts>
                    <units></units>
                    <delta>0</delta>
                    <snmpv3_securityname></snmpv3_securityname>
                    <snmpv3_securitylevel>0</snmpv3_securitylevel>
                    <snmpv3_authpassphrase></snmpv3_authpassphrase>
                    <snmpv3_privpassphrase></snmpv3_privpassphrase>
                    <formula>1</formula>
                    <delay_flex></delay_flex>
                    <params></params>
                    <ipmi_sensor></ipmi_sensor>
                    <data_type>0</data_type>
                    <authtype>0</authtype>
                    <username></username>
                    <password></password>
                    <publickey></publickey>
                    <privatekey></privatekey>
                    <port></port>
                    <description></description>
                    <inventory_link>0</inventory_link>
                    <applications/>
                    <valuemap/>
                </item>
            </items>
            <discovery_rules/>
            <macros/>
            <templates/>
            <screens/>
        </template>
    </templates>
    <triggers>
        <trigger>
            <expression>{tempate1:sanitycheck.sh.last(0)}=1</expression>
            <name>trigger1</name>
            <url></url>
            <status>0</status>
            <priority>0</priority>
            <description></description>
            <type>0</type>
            <dependencies/>
        </trigger>
        <trigger>
            <expression>{tempate1:sanitycheck.sh.last(0)}=0</expression>
            <name>trigger2</name>
            <url></url>
            <status>0</status>
            <priority>0</priority>
            <description></description>
            <type>0</type>
            <dependencies/>
        </trigger>
    </triggers>
</zabbix_export>
#+end_example
*** hosts
#+begin_example
<?xml version="1.0" encoding="UTF-8"?>
<zabbix_export>
    <version>2.0</version>
    <date>2012-07-14T17:01:11Z</date>
    <groups>
        <group>
            <name>mygroup</name>
        </group>
        <group>
            <name>Templates</name>
        </group>
    </groups>
    <hosts>
        <host>
            <host>localhost</host>
            <name>ubuntu</name>
            <proxy/>
            <status>0</status>
            <ipmi_authtype>-1</ipmi_authtype>
            <ipmi_privilege>2</ipmi_privilege>
            <ipmi_username></ipmi_username>
            <ipmi_password></ipmi_password>
            <templates>
                <template>
                    <name>tempate1</name>
                </template>
            </templates>
            <groups>
                <group>
                    <name>mygroup</name>
                </group>
                <group>
                    <name>Templates</name>
                </group>
            </groups>
            <interfaces>
                <interface>
                    <default>1</default>
                    <type>1</type>
                    <useip>1</useip>
                    <ip>127.0.0.1</ip>
                    <dns></dns>
                    <port>10050</port>
                    <interface_ref>if1</interface_ref>
                </interface>
            </interfaces>
            <applications/>
            <items/>
            <discovery_rules/>
            <macros/>
            <inventory/>
        </host>
    </hosts>
</zabbix_export>
#+end_example
** DONE [#A] Sending list of active checks to [127.0.0.1] failed: host [localhost] not found :IMPORTANT:
   CLOSED: [2012-08-06 Mon 15:50]
http://www.zabbix.com/forum/showthread.php?t=24421\\
#+begin_example
In your zabbix_agentd.conf don't use 'localhost'

Try this:

Server=10.15.1.18
Hostname=NameOfServerInZabbixGUI

Note, Hostname is NOT dns name. It is the Name you give in zabbix hosts page.
#+end_example
** DONE [#B] zabbix add favorite graphics                :IMPORTANT:noexport:
   CLOSED: [2012-08-06 Mon 17:57]
#+begin_example
/sshx:root@192.168.75.236: #$ svn diff -r 680:681 http://app.ec-os.net/svn/ecaeroot/trunk/puppet/modules/monitor/templates
Index: zabbix-template.sql
===================================================================
--- zabbix-template.sql	(revision 680)
+++ zabbix-template.sql	(revision 681)
@@ -3,6 +3,7 @@
 <% host_id=80001 -%>
 <% graphid=400 -%>
 <% gitemid=1000 -%>
+<% profileid=400 -%>
 <% zabbix_item_id=90001 -%>
 <% zabbix_trigger_id=70001 -%>
 <% zabbix_function_id=60001 -%>
@@ -11,6 +12,7 @@
 INSERT INTO groups VALUES (<%= groupid %>,'Ecae Servers',1);

 DELETE FROM graphs WHERE name like 'ecae_graph_%';
+DELETE FROM profiles WHERE value_str='ecae favorite graph';
 <% all_servers.each do |server| -%>
 -- Add hosts
 DELETE FROM hosts WHERE hostid=<%= host_id %>;
@@ -21,6 +23,8 @@
 <% hostgroupid=hostgroupid+1 -%>
 -- Add graph for the host
 INSERT INTO graphs(graphid, name, width, height, yaxismin, yaxismax, templateid, show_work_period, show_triggers, graphtype, show_legend, show_3d, percent_left, percent_right, ymin_type, ymax_type, ymin_itemid, ymax_itemid) VALUES (<%= graphid %>, 'ecae_graph_<%= server %>', 900, 200, 0.0000, 100.0000, 0, 0, 0, 0, 0, 0, 0.0000, 0.0000, 0, 0, 0, 0);
+-- Add favorite graphs
+INSERT INTO profiles(profileid, userid, idx, idx2, value_id, value_int, value_str, source, type) values (<%= profileid %>, 1, 'web.favorite.graphids', 0, <%= graphid %>, 0, 'ecae favorite graph', 'graphid', 1);

 DELETE FROM graphs_items WHERE graphid=<%= graphid %>;
 -- DELETE FROM items WHERE description like 'ecae_item_%';
@@ -54,5 +58,6 @@
 <% end -%>
 --######################################################
 <% graphid=graphid+1 -%>
+<% profileid=profileid+1 -%>
 <% host_id=host_id+1 -%>
 <% end -%>
/sshx:root@192.168.75.236: #$
#+end_example
** DONE [#B] zabbix的sql文件更新                         :IMPORTANT:noexport:
   CLOSED: [2012-08-07 Tue 17:09]
#+begin_example
Index: /etc/puppet/modules/monitor/manifests/checktemplate.pp
===================================================================
--- /etc/puppet/modules/monitor/manifests/checktemplate.pp	(revision 693)
+++ /etc/puppet/modules/monitor/manifests/checktemplate.pp	(working copy)
@@ -94,7 +94,7 @@
   }
   exec {
     update-monitor:
-      command=>"/usr/bin/mysql -u${zabbix_server_dbuser} -p${zabbix_server_dbpasswd} -P${zabbix_mysql_port} --socket=/var/lib/mysql/mysql-${zabbix_mysql_port}.sock ${zabbix_server_dbname} < /etc/zabbix/zabbix-template.sql",
+      command=>"/usr/bin/mysql -u${zabbix_server_dbuser} -p${zabbix_server_dbpasswd} -P${zabbix_mysql_port} --socket=/var/lib/mysql/mysql-${zabbix_mysql_port}.sock ${zabbix_server_dbname} < /etc/zabbix/zabbix-template.sql || (> /etc/zabbix/zabbix-template.sql; /bin/false)",
       user=>"root",
       require => Exec["init-zabbix"],
       subscribe => File["/etc/zabbix/zabbix-template.sql"],
#+end_example
** DONE [#A] 保证zabbix的修改不被丢失                    :IMPORTANT:noexport:
   CLOSED: [2012-08-09 Thu 10:59]
- 删除时,不能删除别人自定义的内容
   带特定flag属性的删除; 级联删除;
- 添加时,不能覆盖别人自定义的内容
*** checktemplate.pp
#+begin_example
class monitor::checktemplate {
  ####################### sanity_check #######################
  $zabbix_sanity_check_command_runner=["sanity_check_command_runner", "ecae.sanitycheck[\"$thrift_command_runner_port\"]",300, $all_servers]
  $zabbix_sanity_check_crontab_generator=["sanity_check_crontab_generator", "ecae.sanitycheck[\"$thrift_crontab_generator_port\"]",300, $crontab_generator_servers]
  $zabbix_sanity_check_crontab_scanner=["sanity_check_crontab_scanner", "ecae.sanitycheck[\"$thrift_crontab_scanner_port\"]",300, $crontab_scanner_servers]
  $zabbix_sanity_check_rrda=["sanity_check_rrda", "ecae.sanitycheck[\"$thrift_rrda_mgmt_port\"]",300, $rrda_servers]
  $zabbix_sanity_check_rrdz=["sanity_check_rrdz", "ecae.sanitycheck[\"$thrift_rrdz_mgmt_port\"]", 300, $rrdz_servers]
  $zabbix_sanity_check_elmar=["sanity_check_elmar", "ecae.sanitycheck[\"$thrift_elmar_api_port\"]", 300, $elmar_servers]
  $zabbix_sanity_check_ecae_router=["sanity_check_ecae_router", "ecae.sanitycheck[\"$thrift_ecae_router_port\"]", 300, $ecae_router_servers]
  $zabbix_sanity_check_ecae_webapp=["sanity_check_ecae_webapp", "ecae.sanitycheck[\"$thrift_ecae_webapp_port\"]", 300, $ecae_webapp_servers]
  $zabbix_sanity_check_snake_worker=["sanity_check_snake_worker", "ecae.sanitycheck[\"$thrift_snake_worker_port\"]", 300, $snake_worker_servers]
  $zabbix_sanity_check_missa=["sanity_check_missa", "ecae.sanitycheck[\"$thrift_missa_mgmt_port\"]", 300, $missa_servers]
  $zabbix_sanity_check_imgprosrv=["sanity_check_imgprosrv", "ecae.sanitycheck[\"$thrift_imgprosrv_api_port\"]", 300, $imgprosrv_servers]
  $zabbix_sanity_check_ecae_mgmt=["sanity_check_ecae", "ecae.sanitycheck[\"$thrift_ecae_mgmt_port\"]", 300, $ecae_servers]
  $zabbix_sanity_check_ecae_mongo=["sanity_check_ecae_mongo", "ecae.sanitycheck[\"$thrift_ecae_mongo_port\"]", 300, $ecae_mongo_servers]
  $zabbix_sanity_check_ecae_memcache=["sanity_check_ecae_mongo", "ecae.sanitycheck[\"$thrift_ecae_mongo_port\"]", 300, $ecae_mongo_servers]
  $zabbix_sanity_check_ecae_crypto=["sanity_check_ecae_crypto", "ecae.sanitycheck[\"$thrift_ecae_crypto_port\"]", 300, $ecae_crypto_servers]
  $zabbix_sanity_check_queue_worker=["sanity_check_queue_worker", "ecae.sanitycheck[\"$thrift_queue_worker_port\"]", 300, $queue_worker_servers]

  ####################### rebar_ping #######################
  $zabbix_rebar_ping_command_runner=["rebar_ping_command_runner", "ecae.rebarcheck[\"command_runnerd\"]", 240, $all_servers]
  $zabbix_rebar_ping_ecae=["rebar_ping_ecae", "ecae.rebarcheck[\"ecaed\"]", 240, $ecae_servers]
  $zabbix_rebar_ping_missa=["rebar_ping_missa", "ecae.rebarcheck[\"missad\"]", 240, $missa_servers]
  $zabbix_rebar_ping_crontab_generator=["rebar_ping_crontab_generator", "ecae.rebarcheck[\"crontab_generatord\"]", 240, $crontab_generator_servers]
  $zabbix_rebar_ping_crontab_scanner=["rebar_ping_crontab_scanner", "ecae.rebarcheck[\"crontab_scannerd\"]", 240, $crontab_scanner_servers]
  $zabbix_rebar_ping_rrda=["rebar_ping_rrda", "ecae.rebarcheck[\"rrdad\"]", 240, $rrda_servers]
  $zabbix_rebar_ping_rrdz=["rebar_ping_rrdz", "ecae.rebarcheck[\"rrdzd\"]", 240, $rrdz_servers]
  $zabbix_rebar_ping_elmar=["rebar_ping_elmar", "ecae.rebarcheck[\"elmard\"]", 240, $elmar_servers]
  $zabbix_rebar_ping_snake_worker=["rebar_ping_snake_worker", "ecae.rebarcheck[\"snake_workerd\"]", 240, $snake_worker_servers]
  $zabbix_rebar_ping_queue_worker=["rebar_ping_queue_worker", "ecae.rebarcheck[\"queue_workerd\"]", 240, $queue_worker_servers]
  $zabbix_rebar_ping_reporting=["rebar_ping_reporting", "ecae.rebarcheck[\"reportingd\"]", 240, $reporting_servers]

  ##################### check service status #################
  $zabbix_service_status_zookeeper=["service_status_zookeeper", "ecae.servicestatuscheck[\"zookeeper\"]", 300, $zk_servers]
  $zabbix_service_status_varnish=["service_status_varnish", "ecae.servicestatuscheck[\"varnish\"]", 300, $varnish_servers]
  $zabbix_service_status_mysqld=["service_status_mysqld", "ecae.servicestatuscheck[\"mysqld\"]", 300, $mysql_servers]
  $zabbix_service_status_syslogng=["service_status_syslogng", "ecae.servicestatuscheck[\"syslog-ng\"]", 300, $all_servers]
  $zabbix_service_status_zabbixagent=["service_status_zabbixagent", "ecae.servicestatuscheck[\"zabbix-agent\"]", 300, $all_servers]
  $zabbix_service_status_zabbix=["service_status_zabbix", "ecae.servicestatuscheck[\"zabbix\"]", 300, $zabbix_monitorserver]

  ##################### check orphan process #################
  $zabbix_orphan_process_spawnfcgi=["orphan_process_spawnfcgi", "ecae.orphancheck[\"spawn-fcgi\"]", 300, $all_servers]
  $zabbix_orphan_process_php=["orphan_process_php", "ecae.orphancheck[\"/usr/bin/php\"]", 300, $all_servers]
  $zabbix_orphan_process_smccli_enable=["orphan_process_smccli_enable", "ecae.orphancheck[\"smc_cli -e\"]", 300, $all_servers]
  $zabbix_orphan_process_smccli_getinstance=["orphan_process_smccli_getinstance", "ecae.orphancheck[\"smc_cli -c\"]", 300, $all_servers]
  $zabbix_orphan_process_mongod=["orphan_process_mongod", "ecae.orphancheck[\"/usr/bin/mongod\"]", 300, $all_servers]

  ##################### check worker hang ###################
  $zabbix_worker_hang_spawnfcgi=["worker_hang_spawnfcgi", "ecae.workerhangcheck[\"spawn-fcgi\"]", 300, $all_servers]
  $zabbix_worker_hang_php=["worker_hang_php", "ecae.workerhangcheck[\"/usr/bin/php\"]", 300, $all_servers]
  $zabbix_worker_hang_smccli_option=["worker_hang_smccli_option", "ecae.workerhangcheck[\"smc_cli -c option\"]", 300, $all_servers]
  $zabbix_worker_hang_smccli_listservice=["worker_hang_smccli_listservice", "ecae.workerhangcheck[\"smc_cli -c listservice\"]", 300, $all_servers]
  $zabbix_worker_hang_getinstance=["worker_hang_getinstance", "ecae.workerhangcheck[\"smc_cli -c getinstance\"]", 300, $all_servers]

  ##################### check process resource ###############

  $zabbix_check_list=[ ### sanity_check
                       $zabbix_sanity_check_command_runner, $zabbix_sanity_check_crontab_generator,
                       $zabbix_sanity_check_crontab_scanner, $zabbix_sanity_check_rrda,
                       $zabbix_sanity_check_rrdz, $zabbix_sanity_check_elmar,
                       $zabbix_sanity_check_ecae_router, $zabbix_sanity_check_ecae_webapp,
                       $zabbix_sanity_check_snake_worker, $zabbix_sanity_check_missa,
                       $zabbix_sanity_check_imgprosrv, $zabbix_sanity_check_ecae_mgmt,
                       $zabbix_sanity_check_ecae_mongo, $zabbix_sanity_check_ecae_memcache,
                       $zabbix_sanity_check_ecae_crypto, $zabbix_sanity_check_queue_worker,
                       ### rebar_ping
                       $zabbix_rebar_ping_command_runner, $zabbix_rebar_ping_ecae,
                       $zabbix_rebar_ping_missa, $zabbix_rebar_ping_crontab_generator,
                       $zabbix_rebar_ping_crontab_scanner, $zabbix_rebar_ping_rrda,
                       $zabbix_rebar_ping_rrdz, $zabbix_rebar_ping_elmar,
                       $zabbix_rebar_ping_snake_worker, $zabbix_rebar_ping_queue_worker,
                       $zabbix_rebar_ping_reporting,
                       ### check service status
                       ## TODO: temporarily disable the following, due to priviledge problems
                       # $zabbix_service_status_zookeeper, $zabbix_service_status_varnish,
                       # $zabbix_service_status_mysqld, $zabbix_service_status_syslogng,
                       # $zabbix_service_status_zabbixagent, $zabbix_service_status_zabbix,
                       ### check orphan process
                       $zabbix_orphan_process_spawnfcgi, $zabbix_orphan_process_php,
                       $zabbix_orphan_process_smccli_enable, $zabbix_orphan_process_smccli_getinstance,
                       $zabbix_orphan_process_mongod,
                       ### check worker hang
                       $zabbix_worker_hang_spawnfcgi, $zabbix_worker_hang_php,
                       $zabbix_worker_hang_smccli_option, $zabbix_worker_hang_smccli_listservice,
                       $zabbix_worker_hang_getinstance,
                       ]
  file {
    "/etc/zabbix/externalscripts/rebar_ping.sh":
      mode => 0755, owner => root , group => root,
      content => template("monitor/checktemplate/rebar_ping.sh");
    "/etc/zabbix/zabbix-template.sql":
      mode => 0644, owner => root , group => root,
      content => template("monitor/zabbix-template.sql");
  }
  exec {
    update-monitor:
      command=>"/usr/bin/mysql -u${zabbix_server_dbuser} -p${zabbix_server_dbpasswd} -P${zabbix_mysql_port} --socket=/var/lib/mysql/mysql-${zabbix_mysql_port}.sock ${zabbix_server_dbname} < /etc/zabbix/zabbix-template.sql || (mv /etc/zabbix/zabbix-template.sql /etc/zabbix/zabbix-template.sql.bak; /bin/false)",
      user=>"root",
      require => Exec["init-zabbix"],
      subscribe => File["/etc/zabbix/zabbix-template.sql"],
      refreshonly => true;
  }
}
#+end_example
*** zabbix-template.sql
#+begin_example
DELETE FROM hosts_groups WHERE groupid IN (SELECT groupid FROM groups WHERE name='Ecae Servers');
DELETE FROM functions WHERE triggerid IN (SELECT triggerid FROM triggers WHERE description LIKE 'ecae_trigger_%');
DELETE FROM items WHERE description like 'ecae_item_%';
DELETE FROM triggers WHERE description like 'ecae_trigger_%';
DELETE FROM graphs WHERE name like 'ecae_graph_%';
DELETE FROM profiles WHERE value_str='ecae favorite graph';
DELETE FROM graphs_items WHERE color='009911';
DELETE FROM groups WHERE name = 'Ecae Servers';

<% hostgroupid=100 -%>
<% host_id=80001 -%>
<% zabbix_function_id=60001 -%>
<% groupid=80 -%>
<% graphid=400 -%>
<% gitemid=1000 -%>
<% profileid=400 -%>
<% zabbix_item_id=90001 -%>
<% zabbix_trigger_id=70001 -%>

-- Add host groups
INSERT INTO groups VALUES (<%= groupid %>,'Ecae Servers',1);

<% all_servers.each do |server| -%>
-- Add hosts
REPLACE INTO hosts VALUES (<%= host_id %>,0,'ecae_<%= server %>','<%= server %>',0,'0.0.0.0',<%= zabbix_agent_port %>,0,0,'',0,0,0,0,0,0,623,-1,2,'','',0,0,0,0,0,0,0,0,'',0,0,'','');
-- Add hosts to groups
INSERT INTO hosts_groups(hostgroupid, hostid, groupid) VALUES (<%= hostgroupid %>, <%= host_id %>,<%= groupid %>);
<% hostgroupid=hostgroupid-1 -%>
-- Add graph for the host
INSERT INTO graphs(graphid, name, width, height, yaxismin, yaxismax, templateid, show_work_period, show_triggers, graphtype, show_legend, show_3d, percent_left, percent_right, ymin_type, ymax_type, ymin_itemid, ymax_itemid) VALUES (<%= graphid %>, 'ecae_graph_<%= server %>', 900, 200, 0.0000, 100.0000, 0, 0, 0, 0, 0, 0, 0.0000, 0.0000, 0, 0, 0, 0);
-- Add favorite graphs
INSERT INTO profiles(profileid, userid, idx, idx2, value_id, value_int, value_str, source, type) values (<%= profileid %>, 1, 'web.favorite.graphids', 0, <%= graphid %>, 0, 'ecae favorite graph', 'graphid', 1);

--####### Add zabbix check: sanity_check for elmar #######
<% zabbix_check_list.each do |zabbix_check| -%>
<% zabbix_check_name=zabbix_check[0] -%>
<% zabbix_check_rule=zabbix_check[1] -%>
<% zabbix_check_interval=zabbix_check[2] -%>
<% server_list=zabbix_check[3] -%>
<% if ((server_list.to_s() != "") and (server_list.to_s() != "undef") and (server_list.include? server)) then -%>
-- Add zabbix items
INSERT INTO items VALUES (<%= zabbix_item_id %>,7,'','',161,<%= host_id %>, 'ecae_item_<%= zabbix_check_name %>', '<%= zabbix_check_rule %>',<%= zabbix_check_interval %>,30,365,NULL,NULL,NULL,0,3,'','',0,0,NULL,'',0,'','','0','',0,'',0,0,'','','',0,0,'','','','',0);

-- Add graph items
INSERT INTO graphs_items(gitemid, graphid, itemid, drawtype, sortorder, color , yaxisside, calc_fnc, type, periods_cnt) VALUES (<%= gitemid %>, <%= graphid %>, <%= zabbix_item_id %>, 0, 0, '009911', 0, 2, 0, 5);

-- Add functions
INSERT INTO functions VALUES (<%= zabbix_function_id %>,<%= zabbix_item_id %>,<%= zabbix_trigger_id %>,NULL,'last','0');

-- Add triggers
INSERT INTO triggers VALUES (<%= zabbix_trigger_id %>,'{<%= zabbix_function_id %>}#0','ecae_trigger_<%= zabbix_check_name %>','',0,1,0,0,0,'','',0,0);
<% gitemid=gitemid-1 -%>
<% zabbix_item_id=zabbix_item_id-1 -%>
<% zabbix_function_id=zabbix_function_id-1 -%>
<% zabbix_trigger_id=zabbix_trigger_id-1 -%>
<% end -%>
<% end -%>
--######################################################
<% graphid=graphid-1 -%>
<% profileid=profileid-1 -%>
<% host_id=host_id-1 -%>
<% end -%>
#+end_example
** CANCELED zabbix agent运行命令时,该用户是否有权限
   CLOSED: [2012-08-11 Sat 17:58]
*** zabbix 检测/etc/init.d/zabbix-agent status是否活着
** BYPASS zabbix添加port检查: 返回的结果不好两次处理,自己写脚本来实现了
   CLOSED: [2012-08-22 Wed 16:56]
net.tcp.port[192.168.0.2,80]
  http://www.360doc.com/content/12/0307/12/834950_192437194.shtml
